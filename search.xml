<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MATLAB Chapter-2 规划问题]]></title>
    <url>%2F2019%2F07%2F31%2FMATLAB-Chapter-2-%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[方法名称：规划问题求解 在数学建模中的应用场合：多约束线性规划、整数规划和不太复杂的多约束非线性、整数规划 线性规划 线性规划的实例与定义 【例2-1】中央电视台为改版后的节目播放两套宣传片。其中宣传片甲播映时间为3.5min，广告时间为30s，收视观众为60万人；宣传片乙播映时间为1min，广告时间为1min，收视观众为20万人。广告公司规定每周至少有3.5min广告，而电视台每周只能为该栏目宣传片提高不多于16min的节目时间。电视台每周应播映两套宣传片各多少次才能使得收视观众最多？ 分析：建模是解决线性规划问题极为重要的环节和技术。一个正确的数学模型的建立要求建模者熟悉规划问题的生产和管理内容，明确目标要求和错综复杂的约束条件。首先将已知数据列在下表： 类别 播放片甲 播放片乙 节目要求 片集时间/min 3.5 1 ≤16 广告时间/min 0.5 1 ≥3.5，≤16 收视观众/万人 60 20 设电视台每周应播映片甲\(x\)次，片乙\(y\)次，总收视观众为\(z\)万人，则 目标函数： \[\max z = 60x+20y\] 约束条件： \[4x+2y≤16 \\ 0.5x+y≥3.5 \\ x,y\in N\] 其中，变量\(x,y\)称为决策变量。加上目标函数和约束条件即为一规划问题数学模型的三个要素。由于上面的目标函数及约束条件均为线性函数，故被称为线性规划问题。 在解决实际问题时，把问题归结成一个线性规划数学模型是很重要的一步，但往往也是困难的一步，模型建立的是否恰当直接影响到求解。而选取适当的决策变量，是建立有效模型的关键之一。 线性规划的MATLAB标准形式 线性规划的目标函数可以是求最大值，也可以是求最小值；约束条件的不等号可以是小于号也可以是大于号。为例避免形式多样性带来的不便，MATLAB中规定线性规划的标准形式为： \[\min_xc^Tx \quad s.t.\ Ax≤b\] 其中，\(c\)和\(x\)为\(n\)维列向量；\(b\)为\(m\)维列向量；\(A\)为\(m\times n\)矩阵。 例如线性规划\(max_xc^Tx \quad s.t. \ Ax≥b\)的MATLAB标准型为\(min_x-c^Tx\quad s.t.\ -Ax≤-b\) 线性规划问题解的概念 一般线性规划问题的标准型为： \[\min z=\sum_{j=1}^nc_jx_j\\ s.t. \ \sum_{j=1}^na_{ij}x_j≤b_j,\ i=1,2,…,m\] 满足约束条件式的解\(x=(x_1,x_2,…,x_n)\)称为线性规划问题的可行解，而使目标函数达到最小值的可行解称为最优解。所有可行解构成的集合称为问题的可行域，记为\(R\)。 求解线性规划的MATLAB解法 若线性规划问题有有限最优解，则一定有某个最优解是可行区域的一个极点。基于此，单纯形法的基本思路是：先找出可行域的一个极点，据一定规则判断其是否最优，否则转换到与之相邻的另一极点，并使目标函数值更优；如此下去，直到找到某一最优解为止。 MATLAB中线性规划的标准型为： \[\min_xc^Tx \quad s.t.\ Ax≤b\] 基本函数形式为linprog(c, A, b)，它的返回值是向量\(x\)的值。还有其他一些函数调用形式，如：[x, fval] = linprog(c, A, b, Aeq, beq, LB, UB, X0, OPTIONS)。其中，fval返回目标函数的值；Aeq和beq对应等式约束\(Ax=b\)；LB和UB分别是变量x的下界和上界；X0是x的初始值；OPTIONS是控制参数。 【例2-2】求解线性规划问题：\[\min z = 2x_1+3x_2+x_3\\s.t.\ x_1+4x_2+2x_3≥8\\3x_1+2x_2≥6\\x_1,x_2,x_3≥0\] MATLAB程序如下： 1234c = [2; 3; 1];a = [1, 4, 2; 3, 2, 0];b = [8; 6];[x, y] = linprog(c, -a, -b, [], [], zeros(3, 1)) % []代替Aeq和beq表示缺省 【例2-3】求解下面的优化问题：\[\min z=-5x_1-4x_2-6x_3\\s.t.\ x_1-x_2+x_3≤20\\3x_1+2x_2+4x_3≤42\\3x_1+2x_2≤30\\0≤x_1,0≤x_2,0≤x_3\] 解： 12345&gt;&gt; f = [-5; -4; -6];&gt;&gt; A = [1 -1 1; 3 2 4; 3 2 0];&gt;&gt; b = [20; 42; 30];&gt;&gt; lb = zeros(3, 1);&gt;&gt; [x, fval, exitflag, output, lambda] = linprog(f, A, b, [], [], lb) 结果为： 1234567891011121314151617181920212223242526272829x = % 最优解 0 15.0000 3.0000fval = % 最优值 -78exitflag = % 收敛 1output = iterations: 3 % 迭代次数 constrviolation: 0 message: &apos;Optimal solution found.&apos; algorithm: &apos;dual-simplex&apos; % 所使用规则 firstorderopt: 1.7764e-15lambda = lower: [3×1 double] upper: [3×1 double] eqlin: [] ineqlin: [3×1 double]&gt;&gt; lambda.ineqlinans = 0 1.5000 0.5000&gt;&gt; lambda.lowerans = 1.0000 0 0 【例2-4】求解下列线性规划问题：\[\max_z=2x_1+3x_2-5x_3\\s.t.\ x_1+x_2+x_3=7\\2x_1-5x_2+x_3≥10\\x_1,x_2,x_3≥0\] 解： 123456c = [2; 3; -5];a = [-2, 5, -1];b = -10;aeq = [1, 1, 1];beq = 7;x = linprog(-c, a, b, aeq, beq, zeros(3,1)) 【例2-5】求解下列线性规划问题：\[\max z=170.8582x_1-17.7254x_2+41.2582x_3+2.2182x_4+131.8182x_5-500000\\s.t.\ x_1-0.17037x_2-0.5324x_3+x_5≤0\\0.17037x_2+0.5324x_3≤888115\\x_1+32\%x_2+x_3≤166805\\x_2≤521265.625\\x_3+x_4≤683400\\x_4+x_5≥660000\\x_j≥0,j=1,2,3,4,5\] 解：为了便于求解，将上述求解最大值线性规划问题转化成求解最小值问题：\[\min z&#39;=-170.8582x_1+17.7254x_2-41.2582x_3-2.2182x_4-131.8182x_5+500000x_6\\s.t.\ x_1-0.17037x_2-0.5324x_3+x_5≤0\\0.17037x_2+0.5324x_3≤888115\\x_1+32\%x_2+x_3≤166805\\x_2≤521265.625\\x_3+x_4≤683400\\-x_4-x_5≤-660000\\x_6=1\\x_j≥0,j=1,2,3,4,5\] 1234567f = [-170.8582 17.7254 -41.2582 -2.2182 -131.8182 500000];A = [1 -0.17037 -0.5324 0 1 0; 0 0.17037 0.5324 0 0 0; 1 0.32 1 0 0 0; 0 1 0 0 0 0; 0 0 1 1 0 0; 0 0 0 -1 -1 0];b = [0; 888115; 166805; 521265.625; 683400; -660000];Aeq = [0 0 0 0 0 1];beq = [1];lb = [0; 0; 0; 0; 0; 0];[x, fval, exitflag, output, lambda] = linprog(f, A, b, Aeq, beq, lb, []) 输出结果为： 12345678910x = 1.0e+05 * 0 1.7062 1.1221 5.7119 0.8881 0.0000fval = -1.4079e+07 即\[x_1=0,x_2=170618,x_3=112207,x_4=571193,x_5=88807,x_6=1\\\min z&#39;=-14078646,\max z=-\min z&#39;=14078646\] 非线性规划 如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题。一般说来，解非线性规划要比解线性规划问题困难得多，而且非线性规划也不像线性规划那样有单纯形法这一通用方法。非线性规划目前还没有适用于各种问题的一般算法，各种方法都有自己特定的适用范围。 【例2-6】投资决策问题：某企业有\(n\)个项目可供选择投资，并且至少要对其中一个项目投资。已知该企业拥有总资金\(A\)元，投资于第\(i(i=1,2,…,n)\)个项目需花资金\(a_i\)元，并预计可收益\(b_i\)元。试选择最佳投资方案。 解：设投资决策变量为 \[x_i = \left\{ \begin{array}{l} 1,决定投资第i个项目\\0,决定不投资第i个项目\end{array},i=1,2,…,n\right.\] 则投资总额为\(\sum_{i=1}^na_ix_i\)，投资总收益为\(\sum_{i=1}^nb_ix_i\)。 因为该公司至少要对一个项目投资，并且总的投资金额不能超过总资金\(A\)，故有限制条件： \[0&lt;\sum_{i=1}^na_ix_i≤A\] 由于\(x_i(i=1,2,…,n)\)只取值0或1，所以还有： \[x_i(1-x_i)=0,i=1,2,…,n\] 另外，该公司至少要对一个项目投资，因此有： \[\sum_{i=1}^nx_i≥1\] 最佳投资方案应是投资额最小而总收益最大的方案，所以这个最佳投资决策问题归结为在总资金以及决策变量的限制条件下，极大化利润与总投资之差。因此，其数学模型为： \[\max Q=\sum_{i=1}^nb_ix_i-\sum_{i=1}^na_ix_i\\s.t.\ \left\{\begin{array}{l}0&lt;\sum_{i=1}^na_ix_i≤A\\x_i(1-x_i)=0,i=1,2,…,n\\\sum_{i=1}^nx_i≥1\end{array}\right.\] 该例是在一组等式或不等式的约束下，求一个函数的最大值问题，其中目标函数或约束条件中至少有一个非线性函数，这类问题称之为非线性规划问题，简记为(NP)。可概括为一般形式： \[\min f(x)\\ s.t.\ h_j(x)≤0, j=1,2,…,q\\g_i(x)=0,i=1,2,…,p\] 其中，\(x=[x_1\ x_2\ …\ x_n]^T\)称为模型(NP)的决策变量；\(f\)称为目标函数；\(g_i(i=1,2,…,p)\)和\(h_i(j=1,2,…,q)\)称为约束函数。另外，\(g_i(x)=0(i=1,2,…,p)\)称为等式约束；\(h_j(x)≤0(j=1,2,…,q)\)称为不等式约束。 非线性规划的MATLAB解法 在MATLAB中非线性规划的数学模型可写成以下形式： \[\min f(x)\\s.t.\left\{ \begin{array}{l} Ax≤B\\ Aeq·x=Beq\\ C(x)≤0\\ Ceq(x)=0\end{array}\right.\] 其中，\(f(x)\)是标量函数；\(A,B,Aeq,Beq\)是相应维数的矩阵和向量；\(C(x),Ceq(x)\)是非线性向量函数。 MATLAB中的命令是： 1X = FMINCON(FUN, X0, A, B, Aeq, Beq, LB, UB, NONLCON, OPTIONS) 它的返回值是向量\(x\)。其中，FUN是用M文件定义的函数f(x)。X0是\(x\)的初始值。A,B,Aeq,Beq定义了线性约束\(Ax≤B,Aeq·x=Beq\)，如果没有线性约束，则A=[],B=[],Aeq=[],Beq=[]。LB和UB是变量\(x\)的下界和上界，如果上界和下界没有约束，则LB=[],UB=[]；如果\(x\)无下界，则LB=-inf；如果\(x\)无上界，则UB=inf。NONLCON是用M文件定义的非线性向量函数\(C(x),Ceq(x)\)。OPTIONS定义了优化参数，可以使用MATLAB默认的参数设置。 【例2-7】求下列非线性规划问题： \[\min f(x)=x_1^2+x_2^2+8\\s.t.\left\{\begin{array}{l}x_1^2-x_2≥0\\ -x_1-x_2^2+2=0\\ x_1,x_2≥0\end{array}\right.\] 编写M文件fun1.m和fun2.m 12function f = fun1(x);f = x(1)^2+x(2)^2+8; 123function [g, h] = fun2(x);g = -x(1)^2+x(2);h = -x(1)-x(2)^2+2; % 等式约束 在MATLAB中执行： 12options = optimset;[x, y] = fmincon(&apos;fun1&apos;, rand(2,1), [], [], [], [], zeros(2,1), [], &apos;fun2&apos;, options) 就可以求得当\(x_1=1、x_2=1\)时，最小值\(y=10\)。 【例2-8】求下列非线性规划问题： \[\max z = \sqrt{x_1}+\sqrt{x_2}+\sqrt{x_3}+\sqrt{x_4}\\s.t.\left\{\begin{array}{l}x_1≤400\\ 1.1x_1+x_2≤440\\1.21x_1+1.1x_2+x_3≤484\\1.331x_1+1.21x_2+1.1x_3+x_4≤532.4\\ x_i≥0,i=1,2,3,4\end{array}\right.\] 编写M文件，定义目标函数： 12function f = fun44(x)f = -(sqrt(x(1))+sqrt(x(2))+sqrt(x(3))+sqrt(x(4))); 编写M文件，定义约束条件： 123456function [g, ceq] = mycon1(x)g(1) = x(1)-400;g(2) = 1.1*x(1)+x(2)-440;g(3) = 1.21*x(1)+1.1*x(2)+x(3)-484;g(4) = 1.331*x(1)+1.21*x(2)+1.1*x(3)+x(4)-532.4;ceq = 0; 编写主程序： 12345678x0 = [1; 1; 1; 1];lb = [0; 0; 0; 0];ub = [];A = [];b = [];Aeq = [];beq = [];[x, fval] = fmincon(&apos;fun44&apos;, x0, A, b, Aeq, beq, lb, ub, &apos;mycon1&apos;) 结果： 1234567x = 86.1883 104.2878 126.1883 152.6879fval = -43.0860 所以最终结果为： \[x_1=86.19,x_2=104.29,x_3=126.19,x_4=152.69,z=-(-43.09)=43.09\] 二次规划]]></content>
      <categories>
        <category>MCM</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>mcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB Chapter-1 数学建模常规方法]]></title>
    <url>%2F2019%2F07%2F31%2FMATLAB-Chapter-1-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E8%A7%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法名称：常规方法 在数学建模中的应用场合：数据预处理、绘制图形、数据预测 MATLAB与数据文件的交互 MATLAB与Excel的交互 从Excel读入数据到MATLAB中： 1&gt;&gt; a = xlsread(&apos;filename.xlsx&apos;, 2, &apos;A1:B5&apos;) 其中，xlsread函数可实现在MATLAB中读入Excel数据；'filename.xlsx'表示读入数据到Excel所在的路径以及Excel文件名称；2表示位于sheet2；'A1:B5'表示需要读入数据的范围。 其次，是从MATLAB往Excel中写入数据： 1&gt;&gt; xlsread(&apos;filename.xlsx&apos;, a, 3, &apos;B1:C5&apos;) 其中，'filename.xlsx'表示写入Excel工作簿所在的位置，如果指定位置不存在指定的Excel文件，MATLAB会自动创建工作簿；a表示待写入的数据；3表示sheet3；'B1:C5'表示写入Excel中的具体位置。 不要在MATLAB正在读写操作的时候打开Excel工作簿，这样有可能使程序终止运行。xlsread函数和xlswrite函数非常实用，比如在数学建模中经常会用到大量数据，如果这些数据全部贴在程序中显得不美观也影响可读性，而存储在Excel工作簿中就是一个极好的办法。 MATLAB与TXT交互 读入TXT文件 可以使用load函数读入TXT文本文件内容： 1load(&apos;*.txt&apos;) 例如，利用load函数完成一个存储过程： 123&gt;&gt; a = linspace(1, 30, 8);&gt;&gt; save exper.txt a -ascii;&gt;&gt; b = load(&apos;exper.txt&apos;) 其中，save exper.txt a -ascii用来把变量a以ASCII码存储在exper.txt文件中，如果不存在则自动创建。如果TXT文件中存储了不同类型的字符或者数据，分类读取数据就需要使用textread函数了，textread函数读取信息的好处就是可以做到控制输出更精准以及不需要使用fopen命令打开文件就可以直接读取。 1[A, B, C, …] = textread(&apos;filename&apos;, &apos;format&apos;, N, &apos;headerlines&apos;, M) 其中，filename表示需要读入的txt文件名称；format表示读出变量的字段格式；N表示读取的次数，每一次读取一行；headerlines表示从第M+1行开始读入。例如： 1&gt;&gt; [name, type, x, y, answer] = textread(&apos;filename&apos;, &apos;%s Type %d %f %n %s&apos;, 2, &apos;headerlines&apos;, 1) 写入TXT文件内容 fprint函数能把MATLAB里的信息写入到TXT中，可以控制写入到精度。举例来说，%6.2f表示写入TXT的数据是浮点型的，输出的宽度是6，精确到小数点2位。 1234&gt;&gt; file_h = fopen(&apos;filename&apos;, &apos;w&apos;);&gt;&gt; fprint(file_h, &apos;%6.2f %12.8f&apos;, 3.14, 2.718);&gt;&gt; fprint(file_h, &apos;\n %6f %12f&apos;, 3.14, -2.718);&gt;&gt; fclose(file_h) 如果在指定位置找不到指定文件，MATLAB会自动创建。 数据拟合方法 曲线拟合也叫曲线逼近，与插值函数有些区别，其只要求拟合的曲线能合理地反映数据的基本趋势，并不要求曲线一定通过数据点。曲线拟合有几种不同的判别准则，如使偏差的绝对值之和最小、使偏差的最大绝对值最小和使偏差的平方和最小（最小二乘法）。常用的方法是最小二乘法。 多项式拟合 将数据点按多项式的形式进行拟合，使用最小二乘法，可以确定多项式的系数。 多项式拟合指令 polyfit(X, Y, N)：多项式拟合，返回降幂排列的多项式系数。 polyval(P, XI)：计算多项式的值。 其中，X、Y是数据点的值；N是拟合的最高次幂；P是返回的多项式系数；XI是要求的点的横坐标。例如： 123456x = [1 2 3 4 5 6 7 8 9];y = [9 7 6 3 -1 2 5 7 20];P = polyfit(x, y, 3);xi = 0:.2:10; % 取值0～10，中间间距0.2yi = polyval(P, xi);plot(xi, yi, x, y, &apos;r*&apos;); 得到的拟合曲线与原始数据的对照如图： 并非拟合次数越高就越精确，有些点数据偏差较大，拟合次数高，精确度反而下降。 图形窗口的多项式拟合 在图形窗口中可以用菜单方式对数据进行简单快速高效的拟合。先画出数据点： 123&gt;&gt; x = [1 2 3 4 5 6 7 8 9];&gt;&gt; y = [9 7 6 3 -1 2 5 7 20];&gt;&gt; plot(x, y, &apos;r*&apos;); 然后在图形窗口，单击“工具” -&gt; “基本拟合”，打开对话框，进行拟合。 指定函数拟合 在MATLAB中也可以用用户自定义的函数进行拟合。例如： 在MATLAB中画出散点图： 123x = [0; 0.4; 1.2; 2; 2.8; 3.6; 4.4; 5.2; 6; 7.2; 8; 9.2; 10.4; 11.6; 12.4; 13.6; 14.4; 15];y = [1; 0.85; 0.29; -0.27; -0.53; -0.4; -0.12; 0.17; 0.28; 0.15; -0.03; -0.15; -0.071; 0.059; 0.08; 0.032; -0.015; -0.02];plot(x, y, &apos;r*&apos;); 知道其对应的函数形式为\(f(t)=a\cos(kt)e^{wt}\)，则可以用MATLAB进行拟合： 12345678syms tx = [0; 0.4; 1.2; 2; 2.8; 3.6; 4.4; 5.2; 6; 7.2; 8; 9.2; 10.4; 11.6; 12.4; 13.6; 14.4; 15];y = [1; 0.85; 0.29; -0.27; -0.53; -0.4; -0.12; 0.17; 0.28; 0.15; -0.03; -0.15; -0.071; 0.059; 0.08; 0.032; -0.015; -0.02];f = fittype(&apos;a * cos(k * t) * exp(w * t)&apos;, &apos;independent&apos;, &apos;t&apos;, &apos;coefficients&apos;, &#123;&apos;a&apos;, &apos;k&apos;, &apos;w&apos;&#125;);cfun = fit(x, y, f) % 显示拟合函数xi = 0:.1:20;yi = cfun(xi);plot(x, y, &apos;r*&apos;, xi, yi, &apos;b-&apos;); 运行程序，结果如下： 123456789101112警告: Start point not provided, choosing random start point. &gt; In curvefit.attention.Warning/throw (line 30) In fit&gt;iFit (line 307) In fit (line 116) In demo (line 5) cfun = General model: cfun(t) = a * cos(k * t) * exp(w * t) Coefficients (with 95% confidence bounds): a = 0.9987 (0.9835, 1.014) k = 1.001 (0.9958, 1.006) w = -0.2066 (-0.2131, -0.2002) 程序中，fittype是自定义拟合函数；cfun(x, y, f)是根据自定义的拟合函数f来拟合数据x,y。注意：此处数据必须为列向量形式。 command window里给出了Warning，是由a,k,w三个参数的初始值未给出导致的，因此如果拟合结果不理想，可以多运行几次。 曲线拟合工具箱 在command window里直接输入cftool命令打开。 曲线拟合工具箱中包含了各种常用的数据拟合方法，可以对各种函数进行拟合，具体操作方法参考help。 数据拟合应用实例 人口预测模型 下表所列是某地区1971-2000年的人口数据，试给出该地区人口增长的数学模型。 年份 时间变量 t=年份-1970 人口 y/人 年份 时间变量 t=年份-1970 人口 y/人 1971 1 33815 1986 16 34520 1972 2 33981 1987 17 34507 1973 3 34004 1988 18 34509 1974 4 34165 1989 19 34521 1975 5 34212 1990 20 34513 1976 6 34327 1991 21 34515 1977 7 34344 1992 22 34517 1978 8 34458 1993 23 34519 1979 9 34498 1994 24 34519 1980 10 34476 1995 25 34521 1981 11 34483 1996 26 34521 1982 12 34488 1997 27 34523 1983 13 34513 1998 28 34525 1984 14 34497 1999 29 34525 1985 15 34511 2000 30 34527 根据表中数据，作出散点图： 由散点图可以看出，人口随时间的变化呈非线性变化，而且存在一个与横坐标平行的渐近线，所以可以用Logistic曲线模型进行拟合。 因为Logistic曲线模型的基本形式为： \[y = \frac{1}{a+be^{-t}}\] 所以，只要令\(y&#39;=\frac{1}{y},x&#39;=e^{-t}\)，就可以将其转化为直线模型： \[y&#39;=a+bx&#39;\] 下面，用MATLAB进行回归分析拟合计算： 12345678910111213141516171819202122232425262728293031323334353637clearclc% 读入人口数据Y = [33815 33981 34004 34165 34212 34327 34344 34458 34498 34476 34483 34488 34513 34497 34511 34520 34507 34509 34521 34513 34515 34517 34519 34519 34521 34521 34523 34525 34525 34527];% 读入时间变量数据T = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30];% 线性化处理for t = 1:30, x(t) = exp(-t); y(t) = 1/Y(1, t);end% 计算，并输出回归系数Bc = zeros(30, 1) + 1;X = [c, x&apos;];B = inv(X&apos; * X) * X&apos; * y&apos;for i = 1:30, % 计算回归拟合值 z(i) = B(1, 1) + B(2, 1) * x(i); % 计算离差 s(i) = y(i) - sum(y)/30; % 计算误差 w(i) = z(i) - y(i);end% 计算离差平方和SS = s * s&apos;;% 计算回归误差平方和QQ = w * w&apos;;% 计算回归平方和UU = S - Q;% 计算，并输出F检验值F = 28 * U/Q% 计算非线性回归模型的拟合值for j = 1:30, Y(j) = 1/(B(1, 1) + B(2, 1) * exp(-j)); end% 输出非线性回归模型的拟合曲线（Logistics曲线）plot(T, Y) 运行该程序，输出： 回归系数B和F检验值： 123456B = 1.0e-04 * 0.2902 0.0182F = 47.8774 Logistic模型拟合曲线： 薄膜渗透率测定 问题提出 某种医用薄膜有允许一种物质的分子穿透它的功能，在试制时需测定薄膜被这种分子穿透的能力。测定方法如下：用面积为\(S\)的薄膜将容器分成体积分别为\(V_A,V_B\)的两部分，在两部分中分别注满该物质的两种不同浓度的溶液。此时，该物质分子就会穿过薄膜从高浓度溶液向低浓度溶液扩散。已知通过单位面积薄膜分子扩散的速度与膜两侧溶液的浓度差成正比，比例系数\(K\)表征令薄膜被该物质分子穿透的能力，称为渗透率。定时测量容器中薄膜某一侧的溶液浓度值，可以确定\(K\)的数值，试用数学建模的方法解决\(K\)值的求解问题。 数学模型的建立 (1) 假设 薄膜两侧的溶液始终都是均匀的，即在任何时刻膜两侧的每一处溶液的浓度都是相同的。 当两侧浓度不一致时，物质的分子穿透薄膜总是从高浓度向低浓度溶液扩散。 通过单位面积膜分子扩散的速度与膜两侧溶液的浓度成正比。 薄膜是双向同性的，即物质从膜的任何一侧向另一侧渗透的性能是相同的。 (2) 符号说明 \(C_A(t)、C_B(t)\)表示\(t\)时刻膜两侧溶液的浓度。 \(a_A、a_B\)表示初始时刻膜两侧的浓度(单位:\(mg/cm^3\))。 \(K\)表示渗透率。 \(V_A、V_B\)表示由薄膜阻隔的容器两侧的体积。 (3) 模型的建立 考察时段\([t,t+\Delta t]\)薄膜两侧容器中该物质质量的变化。以容器\(A\)为例，在该时段物质质量增加量为： \[V_AC_A(t+\Delta t)-V_AC_A(t)\] 另一方面由渗透率的定义可知，从B侧渗透至A侧的该物质的质量为： \[SK(C_B-C_A)\Delta t\] 由质量守恒定律，两者应该相等，于是有： \[V_AC_A(t+\Delta t)-V_AC_A(t)=SK(C_B-C_A)\Delta t\] 两边同除\(\Delta t\)，令\(\Delta t \to 0\)，整理得： \[\frac{dC_A}{dt}=\frac{SK}{V_A}(C_B-C_A) \tag{1} \] 且注意到整个容器的溶液中含有该物质的质量应该不变，即有下式成立： \[V_AC_A(t)+V_BC_B(t)=V_Aa_A+V_Ba_B\] 因此有： \[C_A(t)=a_A+\frac{V_B}{V_A}a_B-\frac{V_B}{V_A}C_B(t)\] 代入式(1)得： \[\frac{dC_B}{dt}+SK(\frac{1}{V_A}+\frac{1}{V_B})C_B=SK(\frac{a_A}{V_B}+\frac{a_B}{V_A})\] 再利用初始条件\(C_B(0)=a_B\)，解出： \[C_B(t)=\frac{a_AV_A+a_BV_B}{V_A+V_B}+\frac{V_A(a_B-a_A)}{V_A+V_B}e^{-SK(\frac{1}{V_A}+\frac{1}{V_B})t}\] 至此，问题归结为利用\(C_B\)在时刻\(t_j\)的测量数据\(C_j(j=1,2,…,N)\)来辨识参数\(K\)和\(a_A\)、\(a_B\)，对应的数学模型变为求函数： \[\min E(K,a_A,a_B)=\sum_{j=1}^n(C_B(t_j)-C_j)^2\] 令\(a=\frac{a_AV_A+a_BV_B}{V_A+V_B}\)，\(b=\frac{V_A(a_B-a_A)}{V_A+V_B}\)，问题转化为求函数： \[E(K,a_A,a_B)=\sum_{j=1}^n[a+be^{-SK(\frac{1}{V_A}+\frac{1}{V_B})t_j}-C_j]^2\] 的最小值点\((K,a,b)\)。 求解参数 例如，设\(V_A=V_B=1000cm^3,S=10cm^2\)，对容器B部分溶液浓度的测试如下表： \(t_j/s\) 100 200 300 400 500 600 700 800 900 1000 \(C_j/(mg·cm^{-3})\) 4.54 4.99 5.35 5.65 5.90 6.10 6.26 6.39 6.50 6.59 此时极小化函数为： \[E(K,a_A,a_B)=\sum_{j=1}^{10}[a+be^{-0.02Kt_j}-C_j]^2\] 下面用MATLAB进行计算： 编写M文件(curvefun.m)： 123function f = curvefun(x, tdata) f = x(1) + x(2) * exp(-0.02 * x(3) * tdata); % 其中x(1)=a; x(2)=b; x(3)=kend 编写程序(demo.m)： 12345678910tdata = linspace(100, 1000, 10); % 线性等分向量cdata = 1e-05 .* [454 499 535 565 590 610 626 639 650 659];x0 = [0.2, 0.05, 0.05]; % 初值估计opts = optimset(&apos;lsqcurvefit&apos;); % 无约束最优化(非线性曲线拟合)opts = optimset(opts, &apos;PrecondBandWidth&apos;, 0); % 复制一个已存在的，修改特定项x = lsqcurvefit(&apos;curvefun&apos;, x0, tdata, cdata, [], [], opts) % 非线性拟合函数f = curvefun(x, tdata)plot(tdata, cdata, &apos;o&apos;, tdata, f, &apos;r-&apos;)xlabel(&apos;时间/s&apos;)ylabel(&apos;浓度&apos;) 输出结果： 123456x = 0.0063 -0.0034 0.2542% 表示 a=0.0063 b=-0.0034 k=0.2542f = 0.0043 0.0051 0.0056 0.0059 0.0061 0.0062 0.0062 0.0063 0.0063 0.0063% 表示点对应的拟合函数值 曲线的拟合结果如图所示，进一步可求得\(a_A=0.01mg/cm^3,a_b=0.004mg/cm^3\)。 数据可视化 地形地貌图形的绘制 下表所列为某次地貌测量所得结果，对一方形区域\((x, y)\)方向均从1～10，选择某些地点测量其相对于某水平面高度的数据，要求用这些数据尽量准确地绘制出该地区的地形地貌。 1 2 3 4 5 6 7 8 9 10 1 0.02 -0.12 -2.09 -0.58 -0.08 2 0.02 -2.38 -4.96 -0.10 3 0.10 1.00 -3.04 -0.53 0.10 4 3.52 5 -0.43 -1.98 0.77 2.17 6 -2.29 0.69 2.59 0.30 7 -0.09 -0.31 4.27 -0.01 8 5.13 7.40 1.89 0.04 9 0.10 0.58 1.75 -0.11 10 -0.01 0.3 0.01 解决此问题的关键是要将未测量地点的高度用数据插值的方法求出来，然后就可以画出地貌图了。 123456789101112131415[x, y] = meshgrid(1:10); % 构造测量网络h = [0, 0.02, -0.12, 0, -2.09, 0, -0.58, -0.08, 0, 0; 0.02, 0, 0, -2.38, 0, -4.96, 0, 0, 0, -0.10; 0, 0.10, 1.00, 0, -3.04, 0, -0.53, 0, 0.10, 0; 0, 0, 0, 3.52, 0, 0, 0, 0, 0, 0; -0.43, -1.98, 0, 0, 0, 0.77, 0, 2.17, 0, 0; 0, 0, -2.29, 0, 0.69, 0, 2.59, 0, 0.30, 0; -0.09, -0.31, 0, 0, 0, 4.27, 0, 0, 0, -0.01; 0, 0, 0, 5.13, 7.40, 0, 1.89, 0, 0.04, 0; 0.10, 0, 0.58, 0, 0, 1.75, 0, -0.11, 0, 0; 0, -0.01, 0, 0, 0.3, 0, 0, 0, 0, 0.01]; % 构造数据点 [xi, yi] = meshgrid(1:0.1:10); % 构造插值网络 hi = interp2(x, y, h, xi ,yi, &apos;spline&apos;); % 二维插值命令，spline:三次样条插值 surf(hi); % 画出地貌图 xlabel(&apos;x&apos;), ylabel(&apos;y&apos;), zlabel(&apos;z&apos;); 运行得到该地区的地貌形态图，此处用分段三次样条插值会得到更好的效果： 车灯光源投影区域的绘制(CUMCM 2002A) 需要先建立车灯投影的数学模型，然后再根据模型绘制出投影效果图。 利用MATLAB，根据得到的线光源长度，用投点法可画出测试屏上反射光的亮区。 12345678910111213141516p = 0.03;x = 25.026;for y1 = -0.002:0.0004:0.002 y0 = (-0.036:0.001:0.036)&apos; * ones(1, 73); z0 = ones(73, 1) * (-0.036:0.001:0.036); x0 = (y0 .^ 2 + z0 .^ 2) / (2 * p); xn = (p^3 + 4 * x0 * 2 * p .* x0 + p * (-4 * y1 * y0 + 3 * 2*p *x0)) ./ (2 * (p^2 + 2 * p * x0)); yn = (2 * p * x0 .* y0 + p^2 * (-y1 + y0) + y1 * (y0 .^ 2 - z0 .^ 2)) ./ (p^2 + 2 * p * x0); zn = (p^2 + 2* p * x0 + 2* y1 * y0) .* z0 ./ (p^2 + 2 * p * x0); y = y0 + (yn - y0) .* (x - x0) ./ (xn - x0); z = z0 + (zn - z0) .* (x - x0) ./ (xn - x0); plot(y, z, &apos;b.&apos;) xlabel(&apos;y(m)&apos;) ylabel(&apos;z(m)&apos;) hold onend 运行程序，即得到反射光在测试屏上的亮区： 层次分析法(AHP) 层次分析法的应用场景 层次分析法(Analytic Hierarchy Process, AHP)是一种决策方法，它是将半定型、半定量问题转化为定量问题的有效途径，它将各种因素层次化，并逐层比较多种关联因素，为分析和预测事物的发展提供可比较的定量依据，AHP特别适用于那些难以完全用定量进行分析的复杂问题，因此在资源分配、选优排序、政策分析、冲突求解以及决策预报等领域得到广泛的应用。 AHP法的本质是根据人们对事物的认知特征，将感性认识进行定量化的过程。人们在分析多个因素时，大脑很难同时梳理那么多信息，而层次分析法的优势就是通过对因素归纳、分层，并逐层分析和量化事物，以达到对复杂事物的更准确认识，从而帮助决策。 在数学建模中，层次分析法的应用场景比较多，归纳起来，主要有以下几个场景： 评价、评判类的题目。这类题目都可以直接用层次分析法来评价，例如奥运会的评价、彩票方案的评价、导师和学生的相互选择、建模论文的评价、城市空气质量分析等。 资源分配和决策类的题目。这类题目可以转化为评价类的题目，然后按照AHP进行求解，如将一笔资金进行投资，有几个备选项目，那么如何进行投资分配最合理。这里题目中还有一个典型的应用，就是方案的选择问题，比如旅游景点的选择、电脑的挑选、学校的选择、专业的选择等。 一些优化问题，尤其是多目标优化问题。对于通常的优化问题，目前已有成熟的方法求解。然而这些优化问题一旦具有如下特征之一：问题中存在一些难以度量的因素；问题的结构在很大程度上依赖于决策者的经验；问题的某些变量之间存在相关性；需要加入决策者的经验、偏好等因素。这时就很难单纯依靠构造一个优化的数学模型求解。这类问题，通常的做法是借助AHP将复杂的问题转化为典型的便于求解的优化问题，比如多目标规划，借助层次分析法，确定各个目标的权重，从而将多目标规划问题转化为可以求解的单目标规划问题。 AHP MATLAB程序设计 层次分析法中，需要MATLAB的地方主要就是将评判矩阵转化为因素的权重矩阵。通常的做法就是求解矩阵的最大特征根和对应阵向量。在将评判矩阵转化为权重向量的过程中，一般需要先判断评判矩阵的一致性，因为通过一致性检验的矩阵，得到的权重才更可靠。 123456789101112131415161718192021222324252627% AHP权重计算clcclear% 数据读入A = [1 2 6; 1/2 1 4; 1/6 1/4 1]; % 评判矩阵% 一致性检验[n, n] = size(A);[v, d] = eig(A);r = d(1, 1);CI = (r - n)/(n - 1);RI = [0 0 0.58 0.90 1.12 1.24 1.32 1.41 1.45 1.49 1.52 1.54 1.56 1.58 1.59];CR = CI/RI(n);if CR &lt; 0.10 CR_Result = &apos;通过&apos;;else CR_Result = &apos;不通过&apos;;end% 权向量计算w = v(:, 1)/sum(v(:, 1));w = w&apos;;% 结果输出disp(&apos;该判断矩阵权向量计算报告：&apos;);disp([&apos;一致性指标：&apos; num2str(CI)]);disp([&apos;一致性比例：&apos; num2str(CR)]);disp([&apos;一致性检验结果：&apos; CR_Result]);disp([&apos;特征值：&apos; num2str(r)]);disp([&apos;权向量：&apos; num2str(w)]); 运行该程序，得到结果： 123456该判断矩阵权向量计算报告：一致性指标：0.0046014一致性比例：0.0079334一致性检验结果：通过特征值：3.0092权向量：0.58763 0.32339 0.088983 应用这段程序时，只要将评判矩阵输入到程序中，其他地方不需要修改，就可以直接、准确地计算出对应的结果。 只要掌握了层次分析法的应用场景、应用过程和如何由评判矩阵得到权重向量，就可以灵活方便地使用层次分析法解决实际问题了。]]></content>
      <categories>
        <category>MCM</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>mcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Chapter-5 Dimensionality Reduction]]></title>
    <url>%2F2019%2F07%2F31%2FMachineLearning-Chapter-5-Dimensionality-Reduction%2F</url>
    <content type="text"><![CDATA[概述 数据降维是机器学习领域中非常重要的内容。所谓降维，就是指采用某种映射方法，将原高维空间中的数据点映射到低纬度到空间中。降维的本质是学习一个映射函数\(f:x\to y\)，其中\(x\)是原始数据点的表达，目前多使用向量表达形式。\(y\)是数据点映射后的低维向量表达，通常\(y\)的维度小于\(x\)的维度。映射函数\(f\)可能是显式的或隐式的、线性的或非线性的。 目前大部分降维算法处理向量表达的数据，也有一些降维算法处理高阶张量表达的数据。之所以使用降维后的数据表示是因为在原始的高维空间中，包含冗余信息以及噪声信息，在实际应用例如图像识别中造成了误差，降低了准确率；而通过降维，我们希望减少冗余信息所造成的误差，提高识别的精度。又或者希望通过降维算法来寻找数据内部的本质结构特征。 在很多算法中，降维算法成为了数据预处理的一部分，如下面提到的PCA算法。事实上，有一些算法如果没有降维预处理，其实是很难得到很好效果的。 算法 维度灾难与降维 对于k近邻法，最好要求样本点比较密集。理论上给定测试样本\(\vec{x}\)，我们希望在\(\vec{x}\)附近很近的距离\(\delta &gt;0\)范围内总能找到一个训练样本\(\vec{z}\)。假设\(\delta=0.001\)，且所有特征的取值范围都是\([0,1]\)： 若样本只有一个特征，则需要1000个均匀分布的训练样本。此时任何测试样本在其附近\(\delta\)距离范围内总能找到一个训练样本。 若样本只有10个特征，则需要\(10^{30}\)个均匀分布的训练样本。此时任何测试样本在其附近\(\delta\)距离范围内总能找到一个训练样本。 如果特征维度成千上万，则需要的训练样本的数量几乎不可能满足。而且高维空间的距离计算也比较麻烦。在高维情形下出现的数据样本稀疏、距离计算困难等问题是所有机器学习方法共同面临的严重障碍，称为“维度灾难”(curse of dimensionality)。可以通过降维(dimension reduction)来缓解这个问题。 前面章节介绍的线性判别分析(LDA)是一种经典的监督降维算法，主成分分析PCA是一种经典的无监督降维算法。 对于降维效果的评估，通常是比较降维前后学习器的性能。如果性能有所提高，则认为降维起了作用。如果将维数降至二维或者三维，则可以通过可视化技术来直观地判断降维的效果。 主成分分析(PCA) PCA原理 主成分分析(Principal Component Analysis, PCA)是最常用的一种降维方法。为了便于维度变换，有如下假设： 假设样本数据是\(n\)维的 假设原始坐标系为：由标准正交基向量\(\{\vec{i}_1,\vec{i}_2,…,\vec{i}_n\}\)张成的空间，其中\({||\vec{i}_s||}=1\); \(\vec{i}_s·\vec{i}_t=0\), \(s≠t\) 假设经过线性变换后的新坐标系为：由标准正交基向量\(\{\vec{j}_1,\vec{j}_2,…,\vec{j}_n\}\)张成的空间，其中\({||\vec{j}_s||}=1\); \(\vec{j}_s·\vec{j}_t=0\), \(s≠t\) 根据定义，有： \[\vec{j}_s=(\vec{i}_1,\vec{i}_2,…,\vec{i}_n)\left[ \begin{array}{}\vec{j}_s · \vec{i}_1 \\ \vdots \\ \vec{j}_s·\vec{i}_n\end{array}\right ],s=1,2,…,n\]]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>dimensionality reduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF Chapter-2 CTF-SSH]]></title>
    <url>%2F2019%2F07%2F29%2FCTF-Chapter-2-CTF-SSH%2F</url>
    <content type="text"><![CDATA[CTF-SSH 私钥泄漏 实验环境： kali linux: 192.168.50.180 靶场机器: 192.168.50.112 目的：获取靶场机器的flag值 信息探测 对于只是给定一个对应IP地址的靶场机器，我们需要对其进行扫描，探测开放的服务。 渗透其实是针对服务的漏洞探测，然后进行对应的数据包发送，获取机器的最高权限。 挖掘开放服务信息： 1nmap -sV 192.168.50.112 分析探测结果 每一个服务对应计算机的一个端口，用来进行通信。常用端口0～1023端口，在扫描结果中查找特征端口。 针对特殊端口进行探测，尤其对开发大端口的http服务进行排查。 探测大端口的信息 对于开放http服务的大端口，可以采取http://ip:port/的形式访问。 查看源代码获取对应信息；如果没有flag信息，使用工具探测隐藏页面： 1dirb http://ip:port/ 针对隐藏页面分析 直接使用浏览器访问，查看效果、对应源代码。可能会获取到flag，或者下一步对应的提示。 挖掘ssh信息，不断访问获取更多泄漏的ssh秘钥信息。 发现这里有两个敏感目录robots.txt和.ssh，打开robots.txt看看内容 这里有三个目录，打开taxes获得第一个flag 下面我们看看敏感目录.ssh 我们发现访问id_rsa和authorized_keys文件可以进行下载，这里就存在了私钥泄漏。 对私钥进行赋读写权限chmod 600 文件名，ls -alh查看权限。 有了私钥，我们就可以尝试使用ssh命令对靶场机器进行远程登陆，用户名可以在认证关键字文件中发现。 1ssh -i id_rsa simon@192.168.50.112 但是在登录时要求我们输入密码。 解密ssh密钥信息 使用ssh2john将id_rsa秘钥信息转换为john可以识别的信息。(安装:https://github.com/koboi137/john) 12chmod 600 id_rsa/opt/john/ssh2john.py id_rsa &gt; rsacrack 利用字典解密rsacrack信息。 1zcat /usr/share/wordlists/rockyou.txt.gz | john --pipe --rules rsacrack 得到密码：starwars 成功远程登录！pwd查看下当前目录，ls查看下当前目录文件，发现并没有我们想要的。这时候我们应该想到去访问root目录。访问之后确实发现了flag.txt，但是我们确没有权限访问，这时候就是如何提权的问题了。 提升权限 查找具有root权限的文件： 1find / -perm -4000 2&gt;dev/null 这条命令是从根目录开始查找，看哪些命令是具有执行权限的。其中2&gt;dev/null用于防止错误信息。 发现有一条命令是read_message，而我们目录下刚好有个read_message.c文件，查看一下，发现第二个flag和一段c代码。 从c代码可以看出，大概意思就是输入一段文字和已知字符串simon进行匹配，匹配成功输出一段文字和message目录下的一个文件。我们如果输入一个长度为20的数组，如果溢出会不会执行。 输入Simon匹配c，再加入十五个字符，最后再接/bin/sh提升权限。 成功提权，然后我们用提权后的用户去访问之前的flag.txt，拿到第三个flag。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>kali linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF Chapter-1 Introduction]]></title>
    <url>%2F2019%2F07%2F29%2FCTF-Chapter-1-Introduction%2F</url>
    <content type="text"><![CDATA[介绍 CTF(Capture the Flag)是当下一种流行的信息安全竞赛形式。其大致流程是，参数团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。我们把这样的内容称之为"Flag"。 实验环境： 攻击机：kali linux 靶场机器：linux 目的：获取靶场机器上的flag值。 比赛环境的两种方式： 给予在同一局域网中的攻击机和靶场机器，以web方式可以访问攻击机，通过攻击机来渗透靶场机器，获取对应的flag值。 给予一个网线接口，直接连接网线，进行渗透靶场机器，获取对应的flag值。 环境搭建 安装软件：VM、Virtual box 创建靶场机器后，靶场机器要求登陆，可是我们并没有用户名和密码。如果不进行登陆，又如何获得靶场机器的IP地址？ 这里我们在kali中先使用ifconfig命令取到当前IP地址为192.168.50.180， 然后使用netdiscover命令netdiscover -r ip/netmask来对靶场机器的IP进行探测。 1netdiscover -r 192.168.50.1/24 可以看到靶场机器的IP为：192.168.50.112 在得到了IP之后，我们还需要测试连通性，使用ping命令进行测试。 我们可以看到，返回了对应的数据包，表明当前机器和靶场机器是连通的。如果没有返回对应值，那么靶场开启了防火墙。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>kali linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Chapter-4 K-Nearest Neighbor]]></title>
    <url>%2F2019%2F07%2F28%2FMachineLearning-Chapter-4-K-Nearest-Neighbor%2F</url>
    <content type="text"><![CDATA[概述 k近邻法(k-Nearest Neighbor, kNN)是机器学习所有算法中理论最简单，最好理解的算法。它是一种基本的分类与回归方法，它的输入为实例的特征向量，通过计算新数据与训练数据特征值之间的距离，然后选取\(K(K≥1)\)个距离最近的邻居进行分类判断(投票法)或者回归。如果\(K=1\)，那么新数据被简单地分配给其近邻的类。 对于分类问题：输出为实例的类别。分类时，对于新的实例，根据其\(k\)个最近邻的训练实例的类别，通过多数表决等方式进行预测。 对于回归问题：输出为实例的值。回归时，对于新的实例，取其\(k\)个最近邻的训练实例的平均值为预测值。 k近邻法分类的直观理解：给定一个训练数据集，对于新的输入实例，在训练集中找到与该实例最邻近的\(k\)个实例。这\(k\)个实例的多数属于某个类别，则该输入实例就划分为这个类别。 k近邻法不具有显式的学习过程，它是直接预测。实际上它是利用训练数据集对特征向量空间进行划分，并且作为其分类的“模型”。 算法 KNN三要素 k近邻法的三要素：\(k\)值选择、距离度量和分类决策规则(即均值的决策规则)。 k值选择 当\(k=1\)时的k近邻算法称为最近邻算法。此时将训练集中与\(\vec{x}\)最近的点点类别作为\(\vec{x}\)的分类。 \(k\)值的选择会对k近邻法的结果产生重大影响。 若\(k\)值较小，则相当于用较小的邻域中的训练实例进行预测，学习的近似误差减小。 优点：只有与输入实例较近的训练实例才会对预测起作用。 缺点：学习的估计误差会增大，预测结果会对近邻的实例点非常敏感。若近邻的训练实例点刚好是噪声，则预测会出错。即\(k\)值的减小意味着模型整体变复杂，易发生过拟合。 若\(k\)值较大，则相当于用较大的邻域中的训练实例进行预测。 优点：减少学习的估计误差。 缺点：学习的近似误差会增大。这时输入实例较远的训练实例也会对预测起作用，使预测发生错误，即\(k\)值增大意味着模型的整体变简单。当\(k=N\)时，无论输入实例是什么，都将它预测为训练实例中最多的类（即预测结果是一个常量）。此时模型过于简单，完全忽略了训练实例中大量有用的信息。 应用中，\(k\)值一般取一个较小的数值。通常采用交叉验证法来选取最优的\(k\)值，就是比较不同\(k\)值时的交叉验证平均误差率，选择误差率最小的那个\(k\)值。 距离度量 kNN算法要求数据的所有特征都可以做可比较的量化。若在数据特征中存在非数值的类型，必须采取手段将其量化为数值。比如，如果样本特征中包含颜色(红、黑、蓝)一项，颜色之间是没有距离可言的，可通过将颜色转换为灰度值来实现距离计算。另外，样本有多个参数，每一个参数都有自己的定义域和取值范围，它们对距离计算的影响也就不一样，如取值较大的影响力会盖过取值较小的参数。为了公平，样本参数必须做一些归一化处理，最简单的方式就是所有特征的数值都采取归一化处置。 特征空间中两个实例点的距离是两个实例点相似程度的反映。k近邻模型的特征空间一般是\(n\)维实数向量空间\(R^n\)。k近邻模型的特征空间的距离一般为欧氏距离，也可以是一般\(L_p\)距离： \[L_p(\vec{x}_i,\vec{x}_j)=(\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)}|^p)^{1/p} \\ \vec{x}_i,\vec{x}_j\in 𝒳=R^n \\ \vec{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T \\ \vec{x}_j=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T \\ p≥1\] 当\(p=2\)时，为欧氏距离：\(L_2(\vec{x}_i,\vec{x}_j)=(\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)}|^2)^{1/2}\) 当\(p=1\)时，为曼哈顿距离：\(L_1(\vec{x}_i,\vec{x}_j)=\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)}|\) 当\(p=∞\)时，为各维度距离中的最大值：\(L_∞(\vec{x}_i,\vec{x}_j)=\max_l|x_i^{(l)}-x_j^{(l)}|\) 不同的距离度量所确定的最近邻点是不同的。一般情况下，选欧氏距离作为距离度量，但这只适用于连续变量。在文本分类这种非连续变量情况下，汉明距离可以用来作为度量。通常情况下，如果运用一些特殊的算法来计算度量的话，K近邻分类的精度可显著提高，如运用大边缘最近邻法或者近邻成分分析法。 分类决策规则 分类决策通常采用多数表决。也可以基于距离的远近进行加权投票，距离越近的样本权重越大。 多数表决规则等价于经验风险最小化。设分类的损失函数为0-1损失函数，分类函数为\(f\)：\(R^n\to \{c_1,c_2,…,c_K\}\)，误分类概率为：\(P(Y≠f(X))=1-P(Y=f(X))\)。 给定实例\(\vec{x}\in 𝒳\)，其最邻近的\(k\)个训练点构成集合\(N_k(\vec{x})\)。设涵盖\(N_k(\vec{x})\)区域点类别为\(c_j\)（这是个待求的未知量，但它肯定是\(c_1,c_2,…,c_K\)之一），则误分类率为： \[\frac{1}{k}\sum_{\vec{x}_i\in N_k(\vec{x})}I(y_i≠c_j)=1-\frac{1}{k}\sum_{\vec{x}_i\in N_k(\vec{x})}I(y_i=c_j)\] 误分类率就是训练数据的经验风险。要使误分类率最小，即经验风险最小，就要使得\(\sum_{\vec{x}_i\in N_k(\vec{x})}I(y_i=c_j)\)最大。即多数表决： \[c_j=\arg \max_{c_j}\sum_{\vec{x}_i\in N_k(\vec{x})}I(y_i=c_j)\] k近邻算法 k近邻算法的分类算法描述如下： 输入：训练数据集\(T=\{(\vec{x}_1,y_1),(\vec{x}_2,y_2),…,(\vec{x}_N,y_N)\}\), \(\vec{x}_i\in 𝒳 \subseteq R^n\)为实例的特征向量，\(y_i\in 𝒴 =\{c_1,c_2,…,c_K\}\)为实例的类别，\(i=1,2,…,N\)。给定实例特征向量\(\vec{x}\)。 输出：实例\(\vec{x}\)所属的类别\(y\)。 步骤： 根据给定的距离度量，在\(T\)中寻找与\(\vec{x}\)最近邻的\(k\)个点。定义涵盖这\(k\)个点的\(\vec{x}\)的邻域记作\(N_k(\vec{x})\)。 从\(N_k(\vec{x})\)中，根据分类决策规则（如多数表决）决定\(\vec{x}\)的类别\(y\)：\[y=\arg \max_{c_j}\sum_{\vec{x}_i\in N_k(\vec{x})}I(y_i=c_j),i=1,2,…,N;j=1,2,…,K\]其中\(I\)为指示函数：\(I(true)=1,I(false)=0\)。上式中，对于\(y_i,i=1,2,…,N\)只有\(\vec{x}_i\in N_k(\vec{x})\)中的样本点才考虑。 k近邻法的学习有一个明显的特点：它没有显式的训练过程。它在训练阶段仅仅将样本保存起来，训练时间开销为零，等到收到测试样本后再进行处理。 kd树 k近邻法中如何对训练数据进行快速k近邻搜索是个问题。最简单粗暴的办法是：线性扫描。通过计算输入样本与每个训练样本的距离，来找出最近邻的\(k\)个训练样本。当训练集很大时，计算非常耗时。常用的解决方法是使用kd树，它可以大幅提高\(k\)近邻搜索的效率。 kd树是二叉树，表示对\(k\)维空间的一个划分。构造平衡kd树的算法如下： 输入：\(k\)维空间数据集\(T=\{\vec{x}_1,\vec{x}_2,…,\vec{x}_N\},\vec{x}_i\in 𝒳 \subseteq R^k\) 输出：kd树 算法步骤： 开始：构造根节点。选择\(x^{(1)}\)为轴，以\(T\)中所有样本的\(x^{(1)}\)坐标的中位数\(x^{(1)*}\)作为切分点，将根节点的超矩形切分成两个子区域（切分超平面\(x^{(1)}=x^{(1)*}\)）。本次切分产生深度为1的左、右子节点。左子节点对应于坐标\(x^{(1)}&lt;x^{(1)*}\)的子区域；右子节点对应于坐标\(x^{(1)}&gt;x^{(1)*}\)的子区域；落在切分超平面上的点（\(x^{(1)}=x^{(1)*}\)）保存在根节点。 重复：对深度为\(j\)的子节点，选择\(x^{(l)}\)为切分的坐标轴，\(l=j(\mod k)+1\)。本次切分之后，树的深度为\(j+1\)。这里取模，而不是\(l=j+1\)，是因为树的深度可以超过维度\(k\)，此时切分轴又重复回到\(x^{(1)}\)，轮转坐标轴进行切分。 结束：直到所有节点的两个子域中没有样本存在时，切分停止。此时得到kd树。 使用kd树的算法相对复杂。用kd树的最近邻搜索算法(k近邻搜索依次类推)如下： 输入： kd树 样本\(\vec{x}\) 输出：样本\(\vec{x}\)的最近邻点 步骤： 在kd树中找到包含测试点\(\vec{x}\)的叶节点。方法是：从根节点出发，递归向下访问kd树： 若测试点\(\vec{x}\)当前维度的坐标小于切分点的坐标，则查找当前节点的左子节点 若测试点\(\vec{x}\)当前维度的坐标大于切分点的坐标，则查找当前节点的右子节点，在访问过程中记录下访问的各节点的顺序（以便于后面的回退） 以此叶节点为“当前最近”\(\vec{x}_{nst}\)。真实最近点一定在\(\vec{x}\)与“当前最近点”构成的超球体内。\(\vec{x}\)为球心。 设当前考察的节点为\(\vec{x}_i\)，递归向上回退，设回退弹出的节点为\(\vec{x}_{inew}\)（每次回退都是退到kd树的父节点），考察节点\(\vec{x}_{inew}\)所在的超平面与以\(\vec{x}\)为球心、以\(\vec{x}\)到当前最近点\(\vec{x}_{nst}\)的距离为半径的超球体是否相交： 若相交 若\(\vec{x}\)是\(\vec{x}_{inew}\)的左子节点，则进入\(\vec{x}_{inew}\)的右子节点，然后先进行向下搜索，再然后向上回退。 若\(\vec{x}\)是\(\vec{x}_{inew}\)的右子节点，则进入\(\vec{x}_{inew}\)的左子节点，然后先进行向下搜索，再然后向上回退。 若不相交，则直接回退 当回退到根节点时，搜索结束。最后的“当前最近点”即为\(\vec{x}\)的最近邻点。 kd树搜索的平均计算复杂度为\(O(\log N)\)，\(N\)为训练集大小。kd树适合\(N\gg k\)的情形。当\(N\)与维度\(k\)接近时，搜索的效率接近线性扫描。 Python实战 首先导入包： 123import numpy as npimport matplotlib.pyplot as pltfrom sklearn import neighbors, datasets, model_selection 然后加载数据集： 1234567891011def load_classification_data(): digits = datasets.load_digits() X_train = digits.data y_train = digits.target return model_selection.train_test_split(X_train, y_train, test_size=0.25, random_state=0, stratify=y_train)def create_regression_data(n): X = 5 * np.random.rand(n, 1) y = np.sin(X).ravel() y[::5] += 1 * (0.5 - np.random.rand(int(n/5))) return model_selection.train_test_split(X, y, test_size=0.25, random_state=0) 其中，load_classification_data函数使用的是scikit-learn自带的手写识别数据集DigitDataset。该数据集由1797张样本图片组成。每张样本图片都是一个\(8 \times 8\)大小的手写数字位图。create_regression_data函数是在sin(X)基础上添加噪声生成的。 KNN分类(KNeighborsClassifier) scikit-learn中提供了一个KNeighborsClassifier类来实现k近邻法分类模型，其原型为： 1234sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights=&apos;uniform&apos;, algorithm=&apos;auto&apos;, leaf_size=30, p=2, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=None, **kwargs) 参数： n_neighbors：一个整数，指定\(k\)值。 weights：一个字符串或者可调用对象，指定投票权重类型。 'uniform'：本节点的所有邻居节点的投票权重都相等。 'distance'：本节点的所有邻居节点的投票权重与距离成反比。 [callable]：一个可调用对象。它传入距离的数组，返回同样形状的权重数组。 algorithm：一个字符串，指定计算最近邻的算法。 'ball_tree'：使用BallTree算法 'kd_tree'：使用KDTree算法 'brute'：使用暴力搜索法 'auto'：自动决定最合适的算法 leaf_size：一个整数，指定BallTree或者KDTree叶节点规模。它影响树的构建和查询速度。 metric：一个字符串，指定距离度量。默认为'minkowski'距离。 p：整数值，指定在'Minkowski'度量上的指数。如果p=1，对应曼哈顿距离；如果p=2，对应欧拉距离。 n_jobs：并行性。默认为-1，表示派发任务到所有计算机的CPU上。 方法： fit(X, y): 训练模型 predict(X): 用模型进行预测，返回待预测样本的标记 score(X, y): 返回在(X, y)上预测的准确率 predict_proba(X): 返回样本为每种标记的概率 kneighbors([X, n_neighbors, return_distance]): 返回样本点的\(k\)近邻点。如果return_distance=True，同时还返回到这些近邻点的距离。 kneighbors_graph([X, n_neighbors, mode]): 返回样本点的连接图 首先使用KNeighborsClassifier： 123456def demo_KNeighborsClassifier(*data): X_train, X_test, y_train, y_test = data clf = neighbors.KNeighborsClassifier() clf.fit(X_train, y_train) print(&quot;Training score: %f&quot; % clf.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % clf.score(X_test, y_test)) 调用： 12X_train, X_test, y_train, y_test = load_classification_data()demo_KNeighborsClassifier(X_train, X_test, y_train, y_test) 结果如下： 12Training score: 0.991091Testing score: 0.980000 可以看到k近邻法对于测试集的数据预测准确率高达98%，对于训练集的拟合准确率高达99%。 然后考察\(k\)值以及投票策略对于预测性能的影响： 12345678910111213141516171819202122def demo_KNeighborsClassifier_k_w(*data): X_train, X_test, y_train, y_test = data Ks = np.linspace(1, y_train.size, num=100, endpoint=False, dtype=&apos;int&apos;) weights = [&apos;uniform&apos;, &apos;distance&apos;] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) for weight in weights: training_scores = [] testing_scores = [] for K in Ks: clf = neighbors.KNeighborsClassifier(weight=weight, n_neighbors=K) clf.fit(X_train, y_train) training_scores.append(clf.score(X_train, y_train)) testing_scores.append(clf.score(X_test, y_test)) ax.plot(Ks, testing_scores, label=&quot;testing score: weight=%s&quot; % weight) ax.plot(Ks, training_scores, label=&quot;training score: weight=%s&quot; % weight) ax.legend(loc=&apos;best&apos;) ax.set_xlabel(&quot;K&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.05) ax.set_title(&quot;KNeighborsClassifier&quot;) plt.show() 运行结果： 可以看到使用uniform投票策略的情况下（投票权重都相同），分类器随着\(k\)的增长，预测性能稳定下降。这是因为当\(k\)增大时，输入实例较远的训练实例也会对预测起作用，使预测发生错误。 在使用distance投票策略情况下（投票权重与距离成反比），分类器随着\(k\)的增长，对测试集的预测性能相对比较稳定，这是因为虽然\(k\)增大时，输入实例较远的训练实例也会对预测起作用，但因为距离较远，其影响小得多（权重很小）。 然后考察\(p\)值（即距离函数的形式）对于预测性能的影响： 12345678910111213141516171819202122def demo_KNeighborsClassifier_k_p(*data): X_train, X_test, y_train, y_test = data Ks = np.linspace(1, y_train.size, endpoint=False, dtype=&apos;int&apos;) Ps = [1, 2, 10] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) for P in Ps: training_scores = [] testing_scores = [] for K in Ks: clf = neighbors.KNeighborsClassifier(p=P, n_neighbors=K) clf.fit(X_train, y_train) training_scores.append(clf.score(X_train, y_train)) testing_scores.append(clf.score(X_test, y_test)) ax.plot(Ks, testing_scores, label=&quot;testing score: p=%d&quot; % P) ax.plot(Ks, training_scores, label=&quot;training score: p=%d&quot; % P) ax.legend(loc=&apos;best&apos;) ax.set_xlabel(&quot;K&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.05) ax.set_title(&quot;KNeighborsClassifier&quot;) plt.show() 运行结果： 可以看到\(p\)参数对于分类器的预测性能没有任何影响。因为\(L_p(\vec{x}_i,\vec{x}_j)=(\sum_{l=1}^n|x_i^{(l)}-x_j^{(l)}|^p)^{1/p}\)，当\(p=1\)时如果\(\vec{x}_j\)是\(\vec{x}_i\)的最近的点，则当\(p\)为其他值时，该结论也成立。 KNN回归(KNeighborsRegressor) scikit-learn中提供了一个KNeighborsRegressor类来实现k近邻法回归模型，其原型为： 1234sklearn.neighbors.KNeighborsRegressor(n_neighbors=5, weights=&apos;uniform&apos;, algorithm=&apos;auto&apos;, leaf_size=30, p=2, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=None, **kwargs) 参数： n_neighbors：一个整数，指定\(k\)值。 weights：一个字符串或者可调用对象，指定投票权重类型。 'uniform'：本节点的所有邻居节点的投票权重都相等。 'distance'：本节点的所有邻居节点的投票权重与距离成反比。 [callable]：一个可调用对象。它传入距离的数组，返回同样形状的权重数组。 algorithm：一个字符串，指定计算最近邻的算法。 'ball_tree'：使用BallTree算法 'kd_tree'：使用KDTree算法 'brute'：使用暴力搜索法 'auto'：自动决定最合适的算法 leaf_size：一个整数，指定BallTree或者KDTree叶节点规模。它影响树的构建和查询速度。 metric：一个字符串，指定距离度量。默认为'minkowski'距离。 p：整数值，指定在'Minkowski'度量上的指数。如果p=1，对应曼哈顿距离；如果p=2，对应欧拉距离。 n_jobs：并行性。默认为-1，表示派发任务到所有计算机的CPU上。 方法： fit(X, y): 训练模型 predict(X): 用模型进行预测，返回待预测样本的标记 score(X, y): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 kneighbors([X, n_neighbors, return_distance]): 返回样本点的\(k\)近邻点。如果return_distance=True，同时还返回到这些近邻点的距离。 kneighbors_graph([X, n_neighbors, mode]): 返回样本点的连接图 其参数意义以及实例方法与KNeighborsClassifier几乎完全相同。两者区别在于回归分析和分析决策的不同： KNeighborsClassifier将待预测样本点最近邻的\(k\)个训练样本点中出现次数最多的分类作为待预测样本点的分类。 KNeighborsRegressor将待预测样本点最近邻的\(k\)个训练样本点的平均值作为待预测样本点的值。 首先使用KNeighborsRegressor： 123456def demo_KNeighborsRegressor(*data): X_train, X_test, y_train, y_test = data regr = neighbors.KNeighborsRegressor() regr.fit(X_train, y_train) print(&quot;Training score: %f&quot; % regr.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % regr.score(X_test, y_test)) 调用函数： 12X_train, X_test, y_train, y_test = create_regression_data(1000)demo_KNeighborsRegressor(X_train, X_test, y_train, y_test) 这里我们生成了1000个样本数据，结果如下： 12Training score: 0.977765Testing score: 0.958196 然后考察\(k\)值以及投票策略对预测性能的影响： 12345678910111213141516171819202122def demo_KNeighborsRegressor_k_w(*data): X_train, X_test, y_train, y_test = data Ks = np.linspace(1, y_train.size, num=100, endpoint=False, dtype=&apos;int&apos;) weights = [&apos;uniform&apos;, &apos;distance&apos;] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) for weight in weights: training_scores = [] testing_scores = [] for K in Ks: regr = neighbors.KNeighborsRegressor(weights=weight, n_neighbors=K) regr.fit(X_train, y_train) training_scores.append(regr.score(X_train, y_train)) testing_scores.append(regr.score(X_test, y_test)) ax.plot(Ks, testing_scores, label=&quot;testing score: weight=%s&quot; % weight) ax.plot(Ks, training_scores, label=&quot;training score: weight=%s&quot; % weight) ax.legend(loc=&apos;best&apos;) ax.set_xlabel(&quot;K&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.05) ax.set_title(&quot;KNeighborsRegressor&quot;) plt.show() 结果如下，其讨论与KNeighborsClassifier相同。 然后考察\(p\)值（距离函数的形式）对于预测性能的影响： 12345678910111213141516171819202122def demo_KNeighborsRegressor_k_p(*data): X_train, X_test, y_train, y_test = data Ks = np.linspace(1, y_train.size, endpoint=False, dtype=&apos;int&apos;) Ps = [1, 2, 10] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) for P in Ps: training_scores = [] testing_scores = [] for K in Ks: regr = neighbors.KNeighborsRegressor(p=P, n_neighbors=K) regr.fit(X_train, y_train) training_scores.append(regr.score(X_train, y_train)) testing_scores.append(regr.score(X_test, y_test)) ax.plot(Ks, testing_scores, label=&quot;testing score: p=%d&quot; % P) ax.plot(Ks, training_scores, label=&quot;training score: p=%d&quot; % P) ax.legend(loc=&apos;best&apos;) ax.set_xlabel(&quot;K&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.05) ax.set_title(&quot;KNeighborsRegressor&quot;) plt.show() 结果如下，其讨论与KNeighborsClassifier相同。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>knn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Chapter-3 Bayes Classifier]]></title>
    <url>%2F2019%2F07%2F27%2FMachineLearning-Chapter-3-Bayes-Classifier%2F</url>
    <content type="text"><![CDATA[概述 贝叶斯分类是一种分类算法的总称，这种算法均以贝叶斯定理为基础，所以统称为贝叶斯分类。 贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。 贝叶斯分类器的主要特点： 属性可以离散，也可以连续 数学基础扎实，分类效率稳定 对缺失和噪声数据不太敏感 属性如果不相关，分类效果很好；如果相关，则不低于决策树 算法 贝叶斯定理 贝叶斯定理是用数学的方法来解释生活中大家都知道的常识，而机器学习使用的各种算法中，最常见的就是贝叶斯定理。 先验概率是根据以往经验和分析得到的概率。比如：你在山洞门口，觉得山洞中有熊出现的事件为\(Y\)，然后听到山洞中传来一阵熊吼的事件为\(X\)。一开始你以为山洞中有熊的概率为\(P(Y)\)，听到熊吼之后认为有熊的概率为\(P(Y/X)\)。很明显\(P(Y/X)&gt;P(Y)\)。这里： \(P(Y)\)为先验概率，是根据以往的数据分析或者经验得到的概率 \(P(Y/X)\)为后验概率，是得到本次试验的信息从而重新修正的概率 设\(S\)为试验\(E\)的样本空间。\(B_1,B_2,…,B_n\)为\(E\)的一组事件。若： \(B_i\cap B_j=\phi ,i≠j,i,j=1,2,…,n\) \(B_1\cup B_2\cup …\cup B_n=S\) 则称\(B_1,B_2,…,B_n\)为样本空间\(S\)的一个划分。如果\(B_1,B_2,…,B_n\)为样本空间\(S\)的一个划分，则对于每次试验，事件\(B_1,B_2,…,B_n\)中有且仅有一个事件发生。 全概率公式：设试验\(E\)的样本空间为\(S\)，\(A\)为\(E\)的事件，\(B_1,B_2,…,B_n\)为样本空间\(S\)的一个划分，且\(P(B_i)≥0(i=1,2,…,n)\)，则有： \[P(A)=P(A/B_1)P(B_1)+P(A/B_2)P(B_2)+…+P(A/B_n)P(B_n)=\sum_{j=1}^nP(A/B_j)P(B_j)\] 贝叶斯定理：设试验\(E\)的样本空间为\(S\)，\(A\)为\(E\)的事件，\(B_1,B_2,…,B_n\)为样本空间\(S\)的一个划分，且\(P(A)&gt;0\)，\(P(B_i)≥0(i=1,2,…,n)\)，则有： \[P(B_i/A)=\frac{P(A/B_i)P(B_i)}{\sum_{j=1}^nP(A/B_j)P(B_j)}\] 朴素贝叶斯法 原理 设样本\(\vec{x}=(x^{(1)},x^{(2)},…,x^{(n)})^T \in 𝒳 \subseteq R^n\)，设标记\(y\in 𝒴=\{c_1,c_2,…,c_K\}\)。令\(X\)为𝒳上的随机向量，\(Y\)为𝒴上的随机变量，\(P(X,Y)\)为\(X\)和\(Y\)的联合概率分布。假定训练数据集\(T=\{(\vec{x}_1,y_1),(\vec{x}_2,y_2),…,(\vec{x}_N,y_N)\}\)由\(P(X,Y)\)独立同分布产生，那么朴素贝叶斯法可从训练数据集中学习联合概率分布\(P(X,Y)\)，也就是学习下列概率分布： 先验概率分布：\(P(Y=c_k),k=1,2,…,K\) 条件概率分布：\(P(X=\vec{x}/Y=c_k),k=1,2,…,K\) 朴素贝叶斯法假设：在分类确定的条件下，用于分类的特征是条件独立的。即： \[P(X=\vec{x}/Y=c_k)=P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)},…,X^{(n)}=x^{(n)}/Y=c_k) \\ =\prod_{j=1}^nP(X^{(j)}=x^{(j)}/Y=c_k),k=1,2,…,K\] 根据贝叶斯定理： \[P(Y=c_k/X=\vec{x})=\frac{P(X=\vec{x}/Y=c_k)P(Y=c_k)}{\sum_{j=1}^KP(X=\vec{x}/Y=c_j)P(Y=c_j)}\] 考虑分类特征的条件独立假设有： \[P(Y=c_k/X=\vec{x})=\frac{P(Y=c_k)\prod_{i=1}^nP(X^{(i)}=x^{(i)}/Y=c_k)}{\sum_{j=1}^KP(X=\vec{x}/Y=c_j)P(Y=c_j)},k=1,2,…,K\] 于是朴素贝叶斯分类器表示为： \[y=f(\vec{x})=\arg \max_{c_k}\frac{P(Y=c_k)\prod_{i=1}^nP(X^{(i)}=x^{(i)}/Y=c_k)}{\sum_{j=1}^KP(X=\vec{x}/Y=c_j)P(Y=c_j)}\] 由于对所有的\(c_k,k=1,2,…,K\)，上式的分母都相同，因此上式可重写为： \[y=f(\vec{x})=\arg \max_{c_k}P(Y=c_k)\prod_{i=1}^nP(X^{(i)}=x^{(i)}/Y=c_k)\] 朴素贝叶斯法的学习 在朴素贝叶斯法中，要学习的参数就是以下两种概率： 先验概率\(P(Y=c_k)\) 条件概率\(P(X^{(j)}=x^{(j)}/Y=c_k)\) 通常采用极大似然估计这两种概率。 先验概率\(P(Y=c_k)\)的极大似然估计为：\[P(Y=c_k)=\frac{1}{N}\sum_{i=1}^NI(y_i=c_k),k=1,2,…,K\] 条件概率\(P(X^{(j)}=a_{jl}/Y=c_k)\)的极大似然估计为：\[P(X^{(j)}=a_{jl}/Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)}\\j=1,2,…,n ;l=1,2,…,s_j ; k=1,2,…,K\]其中，\(a_{j1},a_{j2},…,a_{js_j}\)为第\(j\)个特征\(x^{(j)}\)可能的取值。 朴素贝叶斯法算法 输入： 训练集\(T=\{(\vec{x}_1,y_1),(\vec{x}_2,y_2),…,(\vec{x}_N,y_N)\}\), \(\vec{x}_i=(x^{(1)}_i,x^{(2)}_i,…,x^{(n)}_i)^T\)，\(x^{(j)}_i\)为第\(i\)个样本的第\(j\)个特征，其中\(x^{(j)}_i\in \{a_{j1},a_{j2},…,a_{js_j}\}\)，\(a_{jl}\)为第\(j\)个特征可能取到的第\(l\)个值，\(j=1,2,…,n\)，\(l=1,2,…,s_j\)，\(y_i\in \{c_1,c_2,…,c_K\}\)。 实例\(\vec{x}\) 输出：实例\(\vec{x}\)的分类 算法步骤： 计算先验概率的估计值以及条件概率的估计值：\[P(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)}{N},k=1,2,…,K \\ P(X^{(j)}=a_{jl}/Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)} \\ j=1,2,…,n; l=1,2,…,s_j; k=1,2,…,K\] 对于给定的实例\(\vec{x}=(x^{(1)},x^{(2)},…,x^{(n)})^T\)，计算：\[P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}/Y=c_k),k=1,2,…,K\] 计算并返回实例\(\vec{x}\)的分类\(y\)：\[y=\arg \max_{c_k}P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}/Y=c_k)\] 贝叶斯估计 设第\(j\)个特征\(x^{(j)}\)可能的取值为\(a_{j1},a_{j2},…,a_{js_j}\)，则条件概率\(P(X^{(j)}=a_{jl}/Y=c_k)\)的极大似然估计为： \[P(X^{(j)}=a_{jl}/Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)} \\ j=1,2,…,n; l=1,2,…,s_j; k=1,2,…,K\] 用极大似然估计可能会出现分母\(\sum_{i=1}^NI(y_i=c_k)\)为0的情况，此时可以采用贝叶斯估计（最大后验估计）： \[P_{\lambda}(X^{(j)}=a_{jl}/Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)+\lambda }{\sum_{i=1}^NI(y_i=c_k)+s_j\lambda } \\ j=1,2,…,n; l=1,2,…,s_j; k=1,2,…,K\] 它等价于在\(X^{(j)}\)的各个取值的频数上赋予一个正数\(\lambda\) 它满足概率分布函数的条件： \[P_{\lambda}(X^{(j)}=a_{jl}/Y=c_k)&gt;0;l=1,2,…,s_j;k=1,2,…,K \\ \sum_{l=1}^{s_j}P_{\lambda}(X^{(j)}=a_{jl}/Y=c_k)=1 \] 此时\(P(Y=c_k)\)的贝叶斯估计调整为： \[P_{\lambda}(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)+\lambda}{N+K\lambda}\] 当\(\lambda =0\)时，为极大似然估计 当\(\lambda =1\)时，为拉普拉斯平滑 Python实战 在scikit中有多种不同的朴素贝叶斯分类器，它们的区别就在于假设了不同的\(P(X^{(j)}/y=c_k)\)分布，下面介绍三种常用的朴素贝叶斯分类器： GaussianNB是高斯贝叶斯分类器。它假设特征的条件概率分布满足高斯分布：\[P(X^{(j)}/y=c_k)=\frac{1}{\sqrt{2\pi \sigma_k^2}}\exp (-\frac{(X^{(j)}-\mu_k)^2}{2\sigma_k^2})\] MultinomialNB是多项式贝叶斯分类器。它假设特征的条件概率分布满足多项式分布：\[P(X^{(j)}=a_{sj}/y=c_k)=\frac{N_{kj}+\alpha }{N_k+\alpha n}\]其中，\(a_{sj}\)表示特征\(X^{(j)}\)的取值，其取值个数为\(s_j\)个；\(N_k=\sum_{i=1}^NI(y_i=c_k)\)，表示属于类别\(c_k\)的样本的数量；\(N_{kj}=\sum_{i=1}^NI(y_i=c_k,X^{(j)}=a_{sj})\)，表示属于类别\(c_k\)且特征\(X^{(j)}=a_{sj}\)的样本的数量。\(\alpha\)就是前述贝叶斯估计中的\(\lambda\)。 BernoulliNB是伯努利贝叶斯分类器。它假设特征的条件概率分布满足二项分布：\[P(X^{(j)}/y=c_k)=pX^{(j)}+(1-p)(1-X^{(j)})\]其中，要求特征的取值为\(X^{(j)}\in \{0,1\}\)，且\(P(X^{(j)}=1/y=c_k)=p\)。 与多项式模型一样，伯努利模型适用于离散特征的情况，所不同的是，伯努利模型中每个特征的取值只能是1和0。 首先导入包： 123from sklearn import datasets, model_selection, naive_bayesimport numpy as npimport matplotlib.pyplot as plt 这里使用的是scikit-learn自带的手写识别数据集Digit Dataset。该数据集由1791张样本图片组成，每张图片都是一个\(8\times 8\)大小的手写数字位图。为了便于处理，scikit-learn将样本图片转换成64维的向量。我们通过下面的函数来观察Digit Dataset数据集： 12345678def show_digits(): digits = datasets.load_digits() fig = plt.figure() print(&quot;vector from images 0:&quot;, digits.data[0]) for i in range(25): ax = fig.add_subplot(5, 5, i+1) ax.imshow(digits.images[i], cmap=plt.cm.gray_r, interpolation=&apos;nearest&apos;) plt.show() 调用该函数，结果如下： 12345vector from images 0: [ 0. 0. 5. 13. 9. 1. 0. 0. 0. 0. 13. 15. 10. 15. 5. 0. 0. 3. 1. 2. 0. 11. 8. 0. 0. 4. 12. 0. 0. 8. 8. 0. 0. 5. 8. 0. 1. 9. 8. 0. 0. 4. 11. 0. 1. 12. 7. 0. 0. 2. 14. 5. 10. 12. 2. 0. 0. 0. 6. 13. 10. 0. 0. 0.] 加载数据集： 123def load_data(): digits = datasets.load_digits() return model_selection.train_test_split(digits.data, digits.target, test_size=0.25, random_state=0) 高斯贝叶斯分类器(GaussianNB) 其原型为：class sklearn.native_bayes.GaussianNB。GaussianNB没有参数，因此不需要调参。 属性： class_prior_: 一个数组，形状为(n_classes,)，是每个类别的概率\(P(y=c_k)\) class_count_: 一个数组，形状为(n_classes,)，是每个类别包含的训练样本数量 theta_: 一个数组，形状为(n_classes, n_features)，是每个类别上每个特征值的均值\(\mu_k\) sigma_: 一个数组，形状为(n_classes, n_features)，是每个类别上每个特征的标准差\(\sigma_k\) 方法： fit(X, y[, sample_weight]): 训练模型 partial_fit(X, y[, classes, sample_weight]): 追加训练模型。该方法主要用于大规模数据集的训练。此时可以将大数据集划分成若干个小数据集，然后在这些小数据集上连续调用partial_fit方法来训练模型。 predict(X): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 123456def demo_GaussianNB(*data): X_train, X_test, y_train, y_test = data cls = naive_bayes.GaussianNB() cls.fit(X_train, y_train) print(&quot;Training score: %.2f&quot; % cls.score(X_train, y_train)) print(&quot;Testing score: %.2f&quot; % cls.score(X_test, y_test)) 运行结果： 12Training score: 0.86Testing score: 0.83 可以看到高斯贝叶斯分类器对训练数据集的预测准确率为86%，对测试数据集的预测准确率为83%。 多项式贝叶斯分类器(MultinomialNB) 其原型为： 1class sklearn.native_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None) 参数： alpha: 一个浮点数，指定\(\alpha\)值 fit_prior: boolean，如果为True，则不去学习\(P(y=c_k)\)，替代以均匀分布。 class_prior: 一个数组，指定了每个分类的先验概率\(P(y=c_1),P(y=c_2),…,P(y=c_K)\)。如果指定了该参数，则每个分类的先验概率不再从数据集中学得。 属性： class_log_prior_: 一个数组对象，形状为(n_classes,)。给出每个类别调整后的经验概率分布的对数值 feature_log_prob_: 一个数组对象，形状为(n_classes, n_features)。给出了\(P(X^{(j)}/y=c_k)\)的经验概率分布的对数值 class_count_: 一个数组，形状为(n_classes,)，是每个类别包含的训练样本数量 feature_count_: 一个数组，形状为(n_classes, n_features)。训练过程中，每个类别每个特征遇到的样本数。 方法： fit(X, y[, sample_weight]): 训练模型 partial_fit(X, y[, classes, sample_weight]): 追加训练模型。该方法主要用于大规模数据集的训练。此时可以将大数据集划分成若干个小数据集，然后在这些小数据集上连续调用partial_fit方法来训练模型。 predict(X): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 123456def demo_MultinomialNB(*data): X_train, X_test, y_train, y_test = data cls = naive_bayes.MultinomialNB() cls.fit(X_train, y_train) print(&quot;Training score: %.2f&quot; % cls.score(X_train, y_train)) print(&quot;Testing score: %.2f&quot; % cls.score(X_test, y_test)) 运行结果： 12Training score: 0.91Testing score: 0.91 接着检验不同的\(\alpha\)对多项式贝叶斯分类器对预测性能的影响： 123456789101112131415161718192021def demo_MultinomialNB_alpha(*data): X_train, X_test, y_train, y_test = data alphas = np.logspace(-2, 5, num=200) training_scores = [] testing_scores = [] for alpha in alphas: cls = naive_bayes.MultinomialNB(alpha=alpha) cls.fit(X_train, y_train) training_scores.append(cls.score(X_train, y_train)) testing_scores.append(cls.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(alphas, training_scores, label=&quot;training score&quot;) ax.plot(alphas, testing_scores, label=&quot;testing score&quot;) ax.set_xlabel(r&quot;$\alpha$&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.0) ax.set_title(&quot;MultinomialNB&quot;) ax.set_xscale(&quot;log&quot;) plt.show() 运行结果： 为了便于观察我们将\(x\)轴设置为对数坐标。可以看到\(\alpha &gt;100\)之后，随着\(\alpha\)的增长，预测准确率在下降。这是因为多项式贝叶斯估计中，假设特征的条件概率分布满足多项式分布：\[P(X^{(j)}=a_{sj}/y=c_k)=\frac{N_{kj}+\alpha }{N_k+\alpha n}\] 当\(\alpha \to ∞\)时，\(\frac{N_{kj}+\alpha }{N_k+\alpha n} \to \frac{1}{n}\)，即对任何类型的特征、该类型特征的任意取值，出现的概率都是\(\frac{1}{n}\)。它完全忽略了各个特征之间的差别，也忽略了每个特征内部的分布。在本问题中总的样本数量在\(10^3\)，\(N_k\)的量级在\(10^2\)，因此在\(\alpha &gt;100\)之后，预测准确率受影响较大。 伯努利贝叶斯分类器(BernoulliNB) 其原型为： 12class sklearn.native_bayes.BernoulliNB(alpha=1.0, binarize=.0, fit_prior=True, class_prior=None) 参数： alpha: 一个浮点数，指定\(\alpha\)值，就是前述贝叶斯估计中的\(\lambda\) binarize: 一个浮点数或者None None: 假定原始数据已经二元化了 浮点数: 以该数为界，特征取值大于它的作为1，特征取值小于它的作为0。采取这种策略来二元化 fit_prior: boolean，如果为True，则不去学习\(P(y=c_k)\)，替代以均匀分布。 class_prior: 一个数组，指定了每个分类的先验概率\(P(y=c_1),P(y=c_2),…,P(y=c_K)\)。如果指定了该参数，则每个分类的先验概率不再从数据集中学得。 属性： class_log_prior_: 一个数组对象，形状为(n_classes,)。给出每个类别调整后的经验概率分布的对数值 feature_log_prob_: 一个数组对象，形状为(n_classes, n_features)。给出了\(P(X^{(j)}/y=c_k)\)的经验概率分布的对数值 class_count_: 一个数组，形状为(n_classes,)，是每个类别包含的训练样本数量 feature_count_: 一个数组，形状为(n_classes, n_features)。训练过程中，每个类别每个特征遇到的样本数。 方法： fit(X, y[, sample_weight]): 训练模型 partial_fit(X, y[, classes, sample_weight]): 追加训练模型。该方法主要用于大规模数据集的训练。此时可以将大数据集划分成若干个小数据集，然后在这些小数据集上连续调用partial_fit方法来训练模型。 predict(X): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 123456def demo_BernoulliNB(*data): X_train, X_test, y_train, y_test = data cls = naive_bayes.BernoulliNB() cls.fit(X_train, y_train) print(&quot;Training score: %.2f&quot; % cls.score(X_train, y_train)) print(&quot;Testing score: %.2f&quot; % cls.score(X_test, y_test)) 运行结果： 12Training score: 0.87Testing score: 0.85 接着检验不同的\(\alpha\)对伯努利贝叶斯分类器预测性能的影响： 12345678910111213141516171819202122def demo_BernoulliNB_alpha(*data): X_train, X_test, y_train, y_test = data alphas = np.logspace(-2, 5, num=200) training_scores = [] testing_scores = [] for alpha in alphas: cls = naive_bayes.BernoulliNB(alpha=alpha) cls.fit(X_train, y_train) training_scores.append(cls.score(X_train, y_train)) testing_scores.append(cls.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(alphas, training_scores, label=&quot;training score&quot;) ax.plot(alphas, testing_scores, label=&quot;testing score&quot;) ax.set_xlabel(r&quot;$\alpha$&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.0) ax.set_title(&quot;BernoullizNB&quot;) ax.set_xscale(&quot;log&quot;) ax.legend(loc=&quot;best&quot;) plt.show() 运行结果： 可以看到\(\alpha &gt;100\)之后，随着\(\alpha\)的增长，预测准确率在下降。原因与多项式贝叶斯分类器的情况相同。 最后考察binarize的参数对伯努利贝叶斯分类器的预测性能的影响。该参数给定了二元化时，0-1的阈值。 123456789101112131415161718192021222324def demo_BernoulliNB_binarize(*data): X_train, X_test, y_train, y_test = data min_x = min(np.min(X_train.ravel()), np.min(X_test.ravel())) - 0.1 max_x = max(np.max(X_train.ravel()), np.max(X_test.ravel())) + 0.1 binarizes = np.linspace(min_x, max_x, endpoint=True, num=100) training_scores = [] testing_scores = [] for binarize in binarizes: cls = naive_bayes.BernoulliNB(binarize=binarize) cls.fit(X_train, y_train) training_scores.append(cls.score(X_train, y_train)) testing_scores.append(cls.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(binarizes, training_scores, label=&quot;training score&quot;) ax.plot(binarizes, testing_scores, label=&quot;testing score&quot;) ax.set_xlabel(&quot;binarize&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_ylim(0, 1.0) ax.set_xlim(min_x - 1, max_x + 1) ax.set_title(&quot;BernoullizNB&quot;) ax.legend(loc=&quot;best&quot;) plt.show() 运行结果： 当指定的binarize的最小值为样本集（包括测试集）所以特征的所有值中的最小值减去0.1，当binarize取最小值时所有特征的所有值都视为1；指定的binarize的最大值为样本集（包括测试集）所以特征的所有值中的最大值加上0.1，当binarize取最大值时所有特征的所有值都视为0。可以看到当binarize太小时，预测准确率断崖式下降，这是因为此时所有特征的所有值都视为0，此时对于伯努利贝叶斯分类器来讲，所有样本的所有特征之间没有任何区分，所以也无从预测。binarize的取值必须在样本集（包括测试集）所有特征的所有值的最小值和最大值之间，且最好能使得二元化之后的特征分布尽可能近似于原始特征的分布。 可以将binarize取“（所有特征的所有值的最小值+所有特征所有值的最大值）/2” 递增式学习partial_fit方法 朴素贝叶斯模型可以用来解决大规模的分类问题，其完整的训练集可能不适合放在内存中。为解决这个问题，上述三个分类器都有一个partial_fit方法，可以动态地增加数据来使用(online classifier)，能够用于递增式学习。 partial_fit的原型为partial_fit(X, y, classes=None, sample_weight=None) X: 样本数据 y: 样本标记 classes: 一个数组对象，形状为(n_classes,)，它列出了所有可能的类别。第一次调用partial_fit时，必须传入该参数，后续的调用不必传入。 sample_weight: 一个数组对象，形状为(n_samples,)。给出每个样本的权重。如果未指定，则全为1. 使用该方法时，最好每次的数据块都足够大，推荐每次填满整个内存。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>bayes classifier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Chapter-2 Decision Tree]]></title>
    <url>%2F2019%2F07%2F26%2FMachineLearning-Chapter-2-Decision-Tree%2F</url>
    <content type="text"><![CDATA[概述 决策树(decision tree)是功能强大而且很受欢迎的分类和预测方法，它是一种有监督的学习算法，以树状图为基础，其输出结果为一系列简单实用的规则。决策树就是一系列的if-then于语句，可以用于分类问题，也可以用于回归问题。 决策树模型基于特征对实例进行分类，它是一种树状结构。优点是可读性强，分类速度快。学习决策树时，通常采用损失函数最小化原则。 本章中，训练集用D表示，T表示一棵决策树。 算法 决策树原理 决策树是一个贪心算法，即在特征空间上执行递归的二元分割，决策树由节点和有向边组成。内部节点表示一个特征或者属性，叶子结点表示一个分类。使用决策树进行分类时，将实例分配到叶节点的类中，该叶节点所属的类就是该节点的分类。 决策树可以表示给定特征条件下，类别的条件概率分布。将特征空间划分为互不相交的单元\(S_1,S_2,…,S_m\)。设某个单元\(S_i\)内部有\(N_i\)个样本点，则它定义了一个条件概率分布\(P(y=c_k/X)\), \(X\in S_i\); \(c_k,k=1,2,…,K\)为第\(k\)个分类。 每个单元对应于决策树的一条路径 所有单元的条件概率分布构成了决策树所代表的条件概率分布 在单元\(S_i\)内部有\(N_i\)个样本点，但是整个单元都属于类\(\hat{c}_k\)。其中，\(\hat{c}_k=\arg_{c_k}\max P(y=c_k/X)\), \(X\in S_i\)。即单元\(S_i\)内部的\(N_i\)个样本点，哪个分类占优，则整个单元都属于该类。 构建决策树的步骤 构建决策树通常包括三个步骤： 特征选择 决策树生成 决策树剪枝 假设给定训练集\(D=\{(\vec{x}_1,y_1),(\vec{x}_2,y_2),…,(\vec{x}_N,y_1N,\}\)，其中\(\vec{x}_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})\)为输入实例，\(n\)为特征个数；\(y_i\in \{1,2,…,K\}\)为类标记，\(i=1,2,…,N\)；\(N\)为样本容量。构建决策树的目标是，根据给定的训练数据集学习一个决策树模型。 构建决策树通常是将正则化的极大似然函数作为损失函数，其学习目标是损失函数为目标函数的最小化。构建决策树的算法通常是递归地选择最优特征，并根据该特征对训练数据进行分割，其步骤如下： 构建根节点，所有训练样本都位于根节点 选择一个最优特征。通过该特征将训练数据分割成子集，确保各个子集有最好的分类，但要考虑下列两种情况： 若子集已能够被较好地分类，则构建叶节点，并将该子集划分到对应的叶节点去 若某个子集不能被较好地分类，则对该子集继续划分 递归直至所有训练样本都被较好地分类，或者没有合适的特征为止 通过该步骤生成的决策树对训练样本有很好的分类能力，但我们需要的是对未知样本的分类能力。因此通常需要对已生成的决策树进行剪枝，从而使得决策树具有更好的泛化能力。剪枝过程是去掉过于细分的叶节点，从而提高泛化能力。 特征选择 特征选择就是选取有较强分类能力的特征。分类能力通过信息增益或者信息增益比来刻画。选择特征的标准就是找出局部最优的特征作为判断进行切分，取决于切分后节点数据集合中类别的有序程度(纯度)，划分后的分区数据越纯，切分规则越合适。衡量节点数据集合的纯度有：熵、基尼系数和方差。熵和基尼系数是针对分类的，方差是针对回归的。 熵 先给出熵(entropy)的定义，设X是一个离散型随机变量，其概率分布为 \[P(X=\vec{x}_i)=p_i,i=1,2,…,n\] 则随机变量\(X\)的熵为： \[H(X)=-\sum_{i=1}^n p_i \log p_i\] 其中，定义\(0\log 0=0\)。 当随机变量\(X\)只取两个值时，\(X\)的分布为： \[P(X=1)=p \\ P(X=0)=1-p,0≤p≤1\] 此时熵为：\(H(P)=-p\log p-(1-p)\log (1-p), 0≤p≤1\) 当\(p=0\)或者\(p=1\)时，熵最小(为0)，此时随机变量不确定性最小 当\(p=0.5\)时，熵最大(为1)，此时随机变量不确定性最大 设随机变量\((X,Y)\)，其联合概率分布为：\(P(X=\vec{x}_i,Y=y_j)=p_{ij}\), \(i=1,2,…,n\); \(j=1,2,…,m\)。则条件熵\(H(Y/X)\)定义为： \[H(Y/X)=\sum_{i=1}^n P_X(X=\vec{x}_i)H(Y/X=\vec{x}_i)\] 其中，\(P_X(X=\vec{x}_i)=\sum_YP(X=\vec{x}_i,Y)\) 当熵中的概率由数据估计得到时，称之为经验熵 当条件熵中的概率由数据估计得到时，称之为经验条件熵 信息增益 对于数据集\(D\)，我们通过\(H(Y)\)来刻画数据集\(D\)的不确定程度。当数据集\(D\)中的所有样本都是同一类别时，\(H(Y)=0\)。也将\(H(Y)\)记作\(H(D)\)。给定特征\(A\)和训练数据集\(D\)，定义信息增益\(g(D,A)\)为：\(g(D,A)=H(D)-H(D/A)\)。 信息增益刻画的是由于特征\(A\)而使得对数据集\(D\)的分类的不确定性减少的程度。构建决策树选择信息增益大的特征来划分数据集。 这里给出计算信息增益的算法。假设训练数据集为\(D\)，\(N\)为其训练数据集容量。假设有\(K\)个类别依次为\(c_k,k=1,2,…,K\)。设\(|C_k|\)为属于类\(c_k\)的样本个数。 设特征\(A\)是离散的，且有\(n\)个不同的取值：\(\{a_1,a_2,…,a_n\}\)，根据特征\(A\)的取值将\(D\)划分出\(n\)个子集：\(D_1,D_2,…,D_n\)，\(N_i\)为对应的\(D_i\)中的样本个数。 设集合\(D_i\)中属于类\(c_k\)的样本集合为\(D_{ik}\)，其容量为\(N_{ik}\)，信息增益算法如下： 输入： 训练数据集\(D\) 特征\(A\) 输出：信息增益\(g(D,A)\) 算法步骤 计算数据集\(D\)的经验熵\(H(D)\)。它就是训练数据集\(D\)中，分类\(Y\)的概率估计\(\hat{P}(Y=c_k)=\frac{|C_k|}{N}\)计算得到的经验熵。\[H(D)=-\sum_{k=1}^K\frac{|C_k|}{N}\log \frac{|C_k|}{N}\] 计算特征\(A\)对于数据集\(D\)的经验条件熵\(H(D/A)\)。它使用了特征\(A\)的概率估计：\(\hat{P}(X^{(A)}=a_i)=\frac{N_i}{N}\)，以及经验条件熵：\(\hat{H}(D/X^{(A)}=a_i)=\sum_{k=1}^K-(\frac{N_{ik}}{N_i}\log \frac{N_{ik}}{N_i})\)（其中使用了条件概率估计\(\hat{P}(Y=c_k/X^{(A)}=a_i)=\frac{N_{ik}}{N_i}\)，意义是：在子集\(D_i\)中\(Y\)的分布）\[H(D/A)=\sum_{i=1}^n\frac{N_i}{N}\sum_{k=1}^K-(\frac{N_{ik}}{N_i}\log \frac{N_{ik}}{N_i})\] 计算信息增益\[g(D,A)=H(D)-H(D/A)\] 熵越大，则表示越混乱；熵越小，则表示越有序。因此信息增益表示混乱的减少程度（有序的增加程度）。 以信息增益作为划分训练集的特征选取方案，存在偏向于选取值较多的特征的问题。公式： \[g(D,A)=H(D)-H(D/A)=H(D)-\sum_{i=1}^n\frac{N_i}{N}\sum_{k=1}^K-(\frac{N_{ik}}{N_i}\log \frac{N_{ik}}{N_i})\] 信息增益比 在极限情况下，特征\(A\)将每一个样本一一对应到对应的节点当中去的时候(每个节点中有且仅有一个样本)，此时\(\frac{N_{ik}}{N_i}=1,i=1,2,…,n\)，条件熵部分为0。而条件熵的最小值为0，这意味着该情况下的信息增益达到了最大值。然而，我们知道这个特征\(A\)显然不是最佳的选择。 可以通过定义信息增益比来解决。特征\(A\)对训练集\(D\)对信息增益比\(g_R(D,A)\)定义为：\[g_R(D,A)=\frac{g(D,A)}{H_A(D)}\\ H_A(D)=-\sum_{i=1}^n\frac{N_i}{N} \log \frac{N_i}{N}\] \(H_A(D)\)刻画了特征\(A\)对训练集\(D\)对分辨能力。但是这不表征它对类别的分辨能力。比如\(A\)将\(D\)切分成了2块\(D_1\)和\(D_2\)，那么很有可能\(H(D)=H(D_1)=H(D_2)\)（如每个子集\(D_i\)中各类别样本的比例与\(D\)中各类别样本的比例相同）。 决策树生成 基础的决策树生成算法中，典型的有ID3生成算法和C4.5生成算法，它们生成树的过程大致相似。ID3是采用的信息增益作为特征选择的度量，而C4.5则采用信息增益比。 ID3生成算法 ID3生成算法应用信息增益准则选择特征，其算法描述如下： 输入： 训练数据集\(D\) 特征集\(A\) 特征信息增益阈值\(\varepsilon &gt;0\) 输出：决策树\(T\) 算法步骤 若\({D}\)中所有实例均属于同一类\({c_k}\)，则\({T}\)为单节点树，并将\(c_k\)作为该节点的坐标记，返回\(T\)。这是一种特殊情况：\(D\)的分类集合只有一个分类。 若\(A=\phi\)，则\(T\)为单节点树，将\(D\)中实例数最大的类\(c_k\)作为该节点的类标记，返回\(T\)（即多数表决）。这也是一种特殊情况：\(D\)的特征集合为空。 否则计算\(g(D,A_i)\)，其中\(A_i \in A\)为特征集合中的各个特征，选择信息增益最大的特征$ A_g $。 判断\({A_g}\)的信息增益 若\({g(D,A_g)&lt; \varepsilon}\)，则置\({T}\)为单节点树，将\({D}\)中实例数最大的类\({c_k}\)作为该节点的类标记，返回\({T}\)。 如果不设置特征信息增益的下限，则可能会使每个叶子都只有一个样本点，从而划分得太细 若\({g(D,A_g)≥ \varepsilon}\)，则对\({A_g}\)特征对每个可能取值\({a_i}\)，根据\({A_g=a_i}\)将\({D}\)划分为若干个非空子集\({D_i}\)，将\({D_i}\)中实例数最大的类作为标记，构建子节点，由子节点及其子节点构成树\({T}\)，返回\({T}\)。 对第\(i\)个子节点，以\(D_i\)为训练集，以\(A-\{A_g\}\)为特征集，递归地调用前面的步骤，得到子树\(T_i\)，返回\(T_i\)。 C4.5生成算法 C4.5生成算法应用信息增益比来选择特征，其算法描述如下： 输入 训练数据集\(D\) 特征集\(A\) 特征信息增益比的阈值\(\varepsilon &gt;0\) 输出：决策树\(T\) 算法步骤 若\(D\)中所有实例均属于同一类\(c_k\)，则\(T\)为单节点树，并将\(c_k\)作为该节点的坐标记，返回\(T\)。这是一种特殊情况：\(D\)的分类集合只有一个分类。 若\({A=\phi }\)，则\(T\)为单节点树，将\(D\)中实例数最大的类\(c_k\)作为该节点的类标记，返回\(T\)（即多数表决）。这也是一种特殊情况：\(D\)的特征集合为空。 否则计算\(g_R(D,A_i)\)，其中\(A_i \in A\)为特征集合中的各个特征，选择信息增益比最大的特征\(A_g\)。 判断\(A_g\)的信息增益比 若\({g_R(D,A_g)&lt;\varepsilon }\)，则置\(T\)为单节点树，将\(D\)中实例数最大的类\(c_k\)作为该节点的类标记(多数表决)，返回\(T\)。 若\({g_R(D,A_g)≥\varepsilon }\)，则对\(A_g\)特征对每个可能取值\(a_i\)，根据\(A_g=a_i\)将\(D\)划分为若干个非空子集\(D_i\)，将\(D_i\)中实例数最大的类作为标记(多数表决)，构建子节点，由子节点及其子节点构成树\(T\)，返回\(T\)。 对第\(i\)个子节点，以\(D_i\)为训练集，以\(A-\{A_g\}\)为特征集，递归地调用前面的步骤，得到子树\(T_i\)，返回\(T_i\)。 说明 C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进： 用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足 在树构造过程中进行剪枝 能够完成对连续属性的离散化处理 能够对不完整数据进行处理 C4.5算法优点：产生的分类规则易于理解，准确率较高。缺点：在构造树过程中，需要对数据集进行多次对顺序扫描和排序，因而导致了算法的低效。此外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。 决策树可能只是用到特征集中的部分特征 C4.5和ID3两个算法只有树的生成算法，生成的树容易产生过拟合。即对训练集匹配很好，但是预测测试集效果较差。 决策树剪枝 决策树需要剪枝的原因：决策树生成算法生成的树对训练数据的预测很准确，但是对于未知的数据分类却很差，这就产生过拟合的现象。发生过拟合是由于决策树太复杂，解决过拟合的方法就是控制模型的复杂度，对于决策树来说就是简化模型，称为剪枝。 决策树剪枝过程是从已生成的决策树上裁掉一些子树或者叶节点。剪枝的目标是通过极小化决策树的整体损失函数或代价函数来实现的。 决策树剪枝的目的是通过剪枝来提高泛化能力。剪枝的思路就是中决策树对训练数据的预测误差和数据复杂度之间找到一个平衡。 设树\(T\)的叶节点个数为\(|T_f|\)，\(t\)为树的叶节点，该叶节点有\(N_t\)个样本点，其中属于\(c_k\)类的样本点有\(N_tk\)，\(k=1,2,…,K\)个。则有：\(\sum_{k=1}^KN_{tk}=N_t\)。 令\(H(t)\)为叶节点\(t\)上的经验熵，\(\alpha ≥0\)为参数，则决策树\(T\)的损失函数定义为： \[C_{\alpha }(T)=\sum_{t=1}^{|T_f|}N_tH(t)+\alpha |T_f|H(t)=-\sum_{k=1}^K\frac{N_{tk}}{N_t}\log \frac{N_{tk}}{N_t}\] 令： \[C(T)=\sum_{t=1}^{|T_f|}N_tH(t)=-\sum_{t=1}^{|T_f|}\sum_{k=1}^KN_{tk}\log \frac{N_{tk}}{N_t}\] 则：\(C_{\alpha }(T)=C(T)+\alpha |T_f|\)，其中\(\alpha |T_f|\)为正则化项，\(C(T)\)表示预测误差。 \(C(T)=0\)意味着\(N_{tk}=N_t\)，即每个节点\(t\)内的样本都是纯的（单一的分类）。 决策树划分得越细致，则\(T\)的叶子节点越多，\(|T_f|\)越大；\(|T_f|\)小于等于样本集的数量，当取等号时，树\(T\)的每个叶子节点只有一个样本点。 参数\(\alpha\)控制预测误差与模型复杂度之间的关系 较大的\(\alpha\)会选择较简单的模型 较小的\(\alpha\)会选择较复杂的模型 \(\alpha =0\)只考虑训练数据与模型的拟合程度，不考虑模型复杂度 剪枝算法描述如下： 输入： 生成树\(T\) 参数\({\alpha}\) 输出：剪枝树\(T_{\alpha}\) 算法步骤如下 计算每个节点的经验熵 递归地从树的叶节点向上回退 设一组叶节点回退到父节点之前与之后的整棵树分别为\(T_t\)与\(T_t&#39;\)，对应的损失函数值分别为\(C_{\alpha }(T_t)\)与\(C_{\alpha }(T_t&#39;)\)。若\(C_{\alpha }(T_t&#39;)≤C_{\alpha }(T_t)\)，则进行剪枝并将父节点变成新的叶节点。 递归进行上一步，直到不能继续为止，得到损失函数最小的子树\(T_{\alpha}\) CART算法 分类与回归树(Classfification And Regression Tree, CART)模型也是一种决策树模型，它即可用于分类，也可用于回归。其学习算法分为两步： 决策树生成：用训练模型生成决策树，生成树尽可能地大 决策树剪枝：基于损失函数最小化的标准，用验证数据对生成的决策树剪枝 分类与回归树模型采用不同的最优化策略。CART回归生成树用平方误差最小化策略，CART分类生成树采用基尼指数最小化策略。 CART回归树 给定训练数据集\(D=\{(\vec{x}_1,y_1),(\vec{x}_2,y_2),…,(\vec{x}_N,y_N)\}\), \(y_i\in R\)。设已经将输入空间划分为\(M\)个单元\(R_1,R_2,…,R_M\)，且在单元\(R_m\)上输出值为\(c_m\), \(m=1,2,…,M\)。则回归树模型为： \[f(\vec{x})=\sum_{m=1}^Mc_mI(\vec{x}\in R_m)\] 其中，\(I(·)\)为示性函数。 如果给定输入空间的一个划分，则回归树在训练数据集上的误差（平方误差）为： \[\sum_{\vec{x}_i\in R_m}(y_i-f(\vec{x}))^2\] 基于平方误差最小的准则，可以求解出每个单元上的最优输出值\(\hat{c}_m\)：\(\hat{c}_m=ave(y_i | \vec{x}_i \in R_m)\)。它就是\(R_m\)上所有输入样本对应的输出\(y_i\)的平均值。 现在需要找到最佳的划分，使得该划分对应的回归树的平方误差在所有划分中最小。设\(\vec{x}_i=(,x_i^{(1)},x_i^{(2)},…,x_i^{(k)})\)，即输入为\(k\)维。选择第\(j\)维\(x_i^{(j)}\)，它的取值\(s\)作为切分变量和切分点。定义两个区域： \[R_1(j,s)=\{\vec{x}|x^{(j)}≤s\} \\ R_2(j,s)=\{\vec{x}|x^{(j)}&gt;s\}\] 然后寻求最优切分变量\(j\)和最优切分点\(s\)。即求解： \[\min_{j,s}[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2]\] 对于给定的维度\(j\)可以找到最优切分点\(s\)。同时: \[\hat{c}_1=ave(y_i|\vec{x}_i\in R_1(j,s)) \\ \hat{c}_2=ave(y_i|\vec{x}_i\in R_2(j,s))\] 问题是如何求解\(j\)：首先遍历所有维度，找到最优切分维度\(j\)；然后对该维度找到最优切分点\(s\)构成一个\((j,s)\)对，并将输入空间划分为两个区域。然后在子区域中重复划分过程，直到满足停止条件为止。这样的回归树称为最小二乘回归树。 最小二乘回归树生成算法描述如下： 输入 训练数据集\(D\) 停止计算条件 输出：CART回归树\(f(\vec{x})\) 算法步骤 选择数据集\(D\)的最优切分维度\(j\)和切分点\(s\)，即求解：\[\min_{j,s}[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2]\] 求解方法：遍历\(j,s\)找到使上式最小的\((j,s)\)对 用选定的\((j,s)\)划分区域并决定相应的输出值：\[R_1(j,s)=\{\vec{x}|x^{(j)}≤s\} \\ R_2(j,s)=\{\vec{x}|x^{(j)}&gt;s\} \\ \hat{c}_1=ave(y_i|\vec{x}_i\in R_1(j,s)) \\ \hat{c}_2=ave(y_i|\vec{x}_i\in R_2(j,s))\] 对子区域\(R_1,R_2\)递归地调用上面两步，直到满足停止条件为止 将输入空间划分为\(M\)个区域\(R_1,R_2,…,R_m\)，生成决策树：\[f(\vec{x})=\sum_{m=1}^M\hat{c_m}I(\vec{x}\in R_m)\] 通常的停止条件为下列条件之一： 节点中样本个数小于预定值 样本集的平方误差小于预定值 没有更多的特征 CART分类树 假设有\(K\)个分类，样本点属于第\(k\)类的概率为\(p_k=P(Y=c_k)\)。定义概率分布的基尼指数为： \[Gini(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum_{k=1}^Kp_k^2\] 对于给定的样本集合\(D\)，设属于类\(c_k\)的样本子集为\(C_k\)，则基尼指数为： \[Gini(D)=1-\sum_{k=1}^K(\frac{|C_k|}{|D|})^2\] 给定特征\(A\),根据其是否取某一个可能值\(a\)，样本集\(D\)被分为两个子集\(D_1\)和\(D_2\)，其中： \[D_1=\{(\vec{x},y)\in D|\vec{x}^{(A)}=a\}\\D_2=\{(\vec{x},y)\in D|\vec{x}^{(A)}≠a\}=D-D_1\] 定义\(Gini(D,A)\)： \[Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)\] 它表示在特征\(A\)的条件下，集合\(D\)的基尼指数。 对于最简单的二项分布，设\(P(X=1)=p,P(X=0)=1-p\)，其基尼系数和熵一样，也是用于度量不确定性。对于样本集\(D\)，\(Gini(D)\)越小说明样本越属于同一类。 CART分类树采用基尼指数选择最优特征，CART分类树的生成算法如下： 输入 训练数据集\(D\) 停止计算条件 输出：CART决策树 算法步骤 对每个特征\(A\)，以及它可能的每个值\(a\)，计算\(Gini(D,A)\)。 选取最优特征和最优切分点：在所有特征\(A\)以及所有的切分点\(a\)中，基尼指数最小的\(A\)和\(a\)就是最优特征和最优切分点。根据最优特征和最优切分点将训练集\(D\)切分成两个子节点。 对两个子节点递归调用上面两步，直到满足停止条件为止。 最终生成CART决策树。 通常的停止条件为下列条件之一： 节点中样本个数小于预定值 样本集的基尼指数小于预定值 没有更多的特征 CART剪枝 CART剪枝是从生成树开始剪掉一些子树，使得决策树变小。剪枝过程由两步组成（假设初始的生成树为\(T_0\)）： 从\(T_0\)开始不断剪枝，知道剪成一棵单节点的树。这些剪枝树形成一个剪枝树序列\(\{T_0,T_1,…,T_n\}\)。 从这个剪枝树序列中挑选出最优剪枝树。方法：通过交叉验证法使用验证数据集对剪枝树序列进行测试。 给出决策树的损失函数为：\({C_{\alpha }(T)=C(T)+\alpha |T|}\)。其中\({C(T)}\)为决策树对训练数据的预测误差；\({|T|}\)为决策树的叶节点个数。 对固定的\(\alpha\)，存在使\(C_{\alpha }(T)\)最小的树。令其为\(T_{\alpha}\)，可以证明\(T_{\alpha}\)是唯一的。 当\(\alpha\)大时，\(C_{\alpha }(T)\)偏小（即决策树比较简单）。 当\(\alpha\)小时，\(C_{\alpha }(T)\)偏大（即决策树比较复杂）。 当\(\alpha =0\)时，生成树就是最优的。 当\(\alpha = ∞\)时，根组成的一个单节点树就是最优的。 考虑生成树\(T_0\)。对\(T_0\)内任意节点\(t\)，以\(t\)为单节点树(记作\(\tilde{t}\))的损失函数为：\(C_{\alpha}(\tilde{t})=C(\tilde{t})+\alpha\)，以\(t\)为根的子树\(T_t\)的损失函数为：\(C_{\alpha }(T_t)=C(T_t)+\alpha |T_t|\)。可以证明： 当\(\alpha =0\)及充分小时，有\(C_{\alpha }(T_t)&lt;C_{\alpha}(\tilde{t})\) 当\(\alpha\)增大到某个值时，有\(C_{\alpha }(T_t)=C_{\alpha}(\tilde{t})\) 当\(\alpha\)再增大时，有\(C_{\alpha }(T_t)&gt;C_{\alpha}(\tilde{t})\) 因此令\(\alpha =\frac{C(\tilde{t})-C(T_t)}{|T_t|-1}\)，此时\(T_t\)与\(\tilde{t}\)有相同的损失函数值，但是\(\tilde{t}\)的叶节点更少。于是对\(T_t\)进行剪枝成一棵单节点树\(\tilde{t}\)了。 对\(T_0\)内部对每一个节点\(t\)，定义\(g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}\)。设\(T_0\)内\(g(t)\)最小的子树为\(T_t^*\)，令该最小值的\(g(t)\)为\(\tilde{\alpha}_1\)。从\(T_0\)剪去\(T_t^*\)，即得到剪枝树\(T_1\)。重复这种过程，直到根节点即完成剪枝过程。在此过程中不断增加\(\tilde{\alpha}_i\)的值，从而生成剪枝树序列。 CART剪枝交叉验证过程是通过验证数据集来测试剪枝树序列\(\{T_0,T_1,…,T_n\}\)中各剪枝树的。对于CART回归树，是考察剪枝树的平方误差，平方误差最小的决策树被认为是最优决策树。对应CART分类树，是考察剪枝树的基尼指数，基尼指数最小的决策树被认为是最优决策树。 CART剪枝算法的描述如下： 输入：CART生成树\(T_0\) 输出：CART剪枝树\(T_{\alpha}\) 算法步骤 令\(k=0,T=T_0,\alpha =∞\) 自下而上地对树\(T\)各内部节点\(t\)计算\(g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}\) 对所有的内部节点，\(\tilde{\alpha}_{k+1}=\min_t(g(t))\)，令\(t^*=\arg \min_t(g(t))\)。对内部节点\(t^*\)进行剪枝得到树\(T_{k+1}\) 令\(T=T_{k+1},k=k+1\) 若\(T\)不是由根节点单独构成的树，则继续前面的步骤 采用交叉验证法在剪枝树序列\(T_0,T_1,…,T_n\)中选取最优剪枝树\(T_{\alpha}\) 连续值和缺失值的处理 连续值 学习任务中常常会遇到连续特征，如个人身高、体重等特征取值就是连续值。可以通过二分法(bi-partition)对连续特征进行离散化处理。 给定样本集\(D\)和连续特征\(A\)，假设该特征在\(D\)上对取值从小到大进行排列为\(a_1,a_2,…,a_M\)。可以选取\(M-1\)个划分点，依次为：\(\frac{a_1+a_2}{2},\frac{a_2+a_3}{2},…,\frac{a_{M-1}+a_M}{2}\)。然后就可以像离散特征一样来考察这些划分点，选取最优的划分点进行样本集合的划分。这也是C4.5算法采取的方案。 缺失值 学习任务中遇到不完整样本，即某些样本的某些特征的取值缺失。如果简单地丢掉这些不完整的样本可能会浪费大量有效的信息。 给定训练集\(D\)和特征\(A\)，令\(\tilde{D}\)表示\(D\)中在特征\(A\)上没有缺失的样本子集。假定特征\(A\)有\(M\)个可取值\(a_1,a_2,…,a_M\)，令\(\tilde{D}^i\)表示\(\tilde{D}\)中最特征\(A\)上取值为\(a_i\)的样本的子集，\(\tilde{D}_k\)表示\(\tilde{D}\)中属于第\(k\)类的样本子集（一共有\(K\)个分类），则有： \[\tilde{D}=\bigcup_{k=1}^K\tilde{D}_k=\bigcup_{i=1}^M\tilde{D}^i\] 假定为每个样本\(\vec{x}\)赋予一个权重\(w_{\vec{x}}\)，定义： \[\rho =\frac{\sum_{\vec{x}\in \hat{D}}w_{\vec{x}}}{\sum_{\vec{x}\in D}w_{\vec{x}}} \\ \tilde{p}_k=\frac{\sum_{\vec{x}\in \tilde{D}_k}w_{\vec{x}}}{\sum_{\vec{x}\in \tilde{D}}w_{\vec{x}}},k=1,2,…,K \\ \tilde{r}_i=\frac{\sum_{\vec{x}\in \tilde{D}^i}w_{\vec{x}}}{\sum_{\vec{x}\in \tilde{D}}w_{\vec{x}}},i=1,2,…,M\] 其物理意义如下： \(\rho\)：表示无缺失值样本占总体样本的比例 \(\tilde{p}_k\)：表示无缺失值样本中，第\(k\)类所占的比例 \(\tilde{r}_i\)：表示无缺失值样本中，在特征\(A\)上取值为\(a_i\)的样本所占的比例 于是可以将信息增益的计算公式修正为： \[g(D,A)=\rho \times g(\tilde{D},A)=\rho \times \lgroup H(\tilde{D})-\sum_{i=1}^M\tilde{r}_iH(\tilde{D}^i)\rgroup\] 其中，\(H(\tilde{D})=-\sum_{k=1}^K\tilde{p}_k\log \tilde{p}_k\)。 在通过特征\(A\)划分样本\(\vec{x}\)时，让它以不同的概率分散到不同的子节点中去： 如果样本在划分特征上的取值已知，则将它划入与其对应的子节点，且权值在子节点中保持为\(w_{\vec{x}}\) 如果样本在划分特征上的取值缺失，则将它同时划入所有的子节点，且在子节点中该样本的权值进行调整：在特征取值为\(a_i\)对应的子节点中，该样本的权值调整为\(\tilde{r}_i \times w_{\vec{x}}\) Python实战 scikit-learn中有两类决策树，均采用优化的CART决策树算法。 回归决策树(DecisionTreeRegressor) DecisionTreeRegressor实现了回归决策树，用于回归问题： 123456789101112class.sklearn.tree.DecisionTreeRegressor(criterion=&quot;mse&quot;, splitter=&quot;best&quot;, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0., max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0., min_impurity_split=None, presort=False) 参数 criterion：字符串，指定切分质量的评价准则。默认为'mse'，且只支持该字符串，表示均方误差。 splitter：字符串，指定切分原则 'best'：选择最优的切分 'random'：随机切分 max_depth：指定树的最大深度 None：表示树的深度不限，直到每个叶子都是纯的，即叶节点中所有样本点都属于一个类，或者叶子中包含小于min_samples_split个样本点 min_samples_split：整数，指定每个内部节点（非叶节点）包含的最少的样本数 min_samples_leaf：整数，指定每个叶节点包含的最少样本数 min_weight_fraction_leaf：浮点数，叶节点中样本的最小权重系数 max_features：指定寻找best split时考虑的特征数量。如果已经考虑了max_features个特征，但是还没有找到一个有效的切分，那么还会继续寻找下一特征，直到找到一个有效的切分为止。 整数：每次切分只考虑max_features个特征 浮点数：每次切分只考虑max_features * n_features个特征（max_features指定了百分比） 'auto' 或者 'sqrt'：max_features = n_features 'log2'：max_features = log2(n_features) None：max_features = n_features random_state: 一个整数或者一个RandomState实例，或者None 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 max_leaf_nodes：指定叶节点的最大数量 None：此时叶节点数量不限 整数：则max_depth被忽略 presort：boolean，指定是否要提前排序数据从而加速寻找最优切分的过程。设置为True时，对于大数据集会减慢总体的训练过程，但是对于一个小数据集或者设定了最大深度的情况下，则会加速训练过程 class_weight：一个字典、字典的列表、'balance'或者None，指定了分类的权重。形式：{class_label: weight}。如果提供了sample_weight参数（fit方法提供），则这些权重都会乘以sample_weight。 None：每个分类权重都为1 'balance'：分类的权重是样本中各分类出现的频率的反比 属性 feature_importances_：给出特征的重要程度。该值越高，则该特征越重要。（Gini importance） max_features_：max_features的推断值 n_features_：当执行fit之后，特征的数量 n_outputs_：当执行fit之后，输出的数量 tree_：一个Tree对象，即底层的决策树 方法 fit(X, y[, sample_weight, check_input, …]): 训练模型 predict(X[, check_input]): 用模型进行预测，返回预测值 score(X, y[, sample_weight]): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 首先导入包 1234import matplotlib.pyplot as pltimport numpy as npfrom sklearn.tree import DecisionTreeRegressorfrom sklearn import model_selection 给出一个随机产生的数据集 123456789101112def create_data(n): &quot;&quot;&quot; 随机产生数据集 :param n: 数据集容量 :return: 一个元组：训练样本集、测试样本集、训练样本集对应的值、测试样本集对应的值 &quot;&quot;&quot; np.random.seed(0) X = 5 * np.random.rand(n, 1) y = np.sin(X).ravel() noise_num = int(n / 5) y[::5] += 3 * (0.5 - np.random.rand(noise_num)) return model_selection.train_test_split(X, y, test_size=0.25, random_state=1) create_data函数产生的数据集是在sin(x)函数基础上添加了若干个随机噪声产生的。x是随机在0～1之间产生的，y是sin(x)，其中y每隔5个点添加一个随机噪声。然后将数据集随机切分成训练集和测试集。指定测试集样本大小为原样本点0.25倍。 然后给出测试函数 12345678910111213141516171819def demo_DecisionTreeRegressor(*data): X_train, X_test, y_train, y_test = data regr = DecisionTreeRegressor() regr.fit(X_train, y_train) print(&quot;Training score: %f&quot; % regr.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % regr.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) X = np.arange(0.0, 5.0, 0.01)[:, np.newaxis] Y = regr.predict(X) ax.scatter(X_train, y_train, label=&quot;train sample&quot;, c=&apos;g&apos;) ax.scatter(X_test, y_test, label=&quot;test sample&quot;, c=&apos;r&apos;) ax.plot(X, Y, label=&quot;predict_value&quot;, linewidth=2, alpha=0.5) ax.set_xlabel(&quot;data&quot;) ax.set_ylabel(&quot;target&quot;) ax.set_title(&quot;Decision Tree Regression&quot;) ax.legend(framealpha=0.5) plt.show() 在demo_DecisionTreeRegressor中，给出了对x上每个点的预测值（考虑到连续值有无穷多，采取的方式是[0, 5]之间，步长为0.01）。调用该函数： 12X_train, X_test, y_train, y_test = create_data(100)demo_DecisionTreeRegressor(X_train, X_test, y_train, y_test) 输出如下： 12Training score: 1.000000Testing score: 0.789107 可以看到对于训练样本的拟合相当好，但是对于测试样本的拟合就差强人意。 接下来，检验随机划分与最优划分的影响： 123456789def demo_DecisionTreeRegressor_splitter(*data): X_train, X_test, y_train, y_test = data splitters = [&apos;best&apos;, &apos;random&apos;] for splitter in splitters: regr = DecisionTreeRegressor(splitter=splitter) regr.fit(X_train, y_train) print(&quot;Splitter %s&quot; % splitter) print(&quot;Training score: %f&quot; % regr.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % regr.score(X_test, y_test)) 运行结果如下： 123456Splitter bestTraining score: 1.000000Testing score: 0.789107Splitter randomTraining score: 1.000000Testing score: 0.778989 可以看到对于本问题，最优划分预测性能较强，但是相差不大。而对于训练集的拟合，二者都拟合得相当好。 最后考察决策树深度的影响。决策树的深度对应着树的复杂度。决策树越深，则模型越复杂。 1234567891011121314151617181920def demo_DecisionTreeRegressor_depth(*data, maxdepth): X_train, X_test, y_train, y_test = data depths = np.arange(1, maxdepth) training_scores = [] testing_scores = [] for depth in depths: regr = DecisionTreeRegressor(max_depth=depth) regr.fit(X_train, y_train) training_scores.append(regr.score(X_train, y_train)) testing_scores.append(regr.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(depths, training_scores, label=&quot;training score&quot;) ax.plot(depths, testing_scores, label=&quot;testing score&quot;) ax.set_xlabel(&quot;maxdepth&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_title(&quot;Decision Tree Regression&quot;) ax.legend(framealpha=0.5) plt.show() 调用该函数 12X_train, X_test, y_train, y_test = create_data(100)demo_DecisionTreeRegressor_depth(X_train, X_test, y_train, y_test, maxdepth=20) 运行结果： 可以看到随着树深度的加深，模型对训练集和预测集的拟合都在提高。由于样本只有100个，因此理论上二叉树最深为\(\log_2(100)=6.65\)。即树深度为7之后，再也无法划分了（每个子节点都只有一个节点）。 绘制不同深度的决策树： 1234567891011121314151617181920def demo_DecisionTreeRegressor_depth_plot(*data): X_train, X_test, y_train, y_test = data depths = [1, 3, 7] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) for depth in depths: regr = DecisionTreeRegressor(max_depth=depth) regr.fit(X_train, y_train) print(&quot;Training score: %f&quot; % regr.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % regr.score(X_test, y_test)) X = np.arange(0.0, 5.0, 0.01)[:, np.newaxis] Y = regr.predict(X) ax.plot(X, Y, label=&quot;predict_value_max_depth=%d&quot; % depth, linewidth=2, alpha=0.5) ax.scatter(X_train, y_train, label=&quot;train sample&quot;, c=&apos;g&apos;) ax.scatter(X_test, y_test, label=&quot;test sample&quot;, c=&apos;r&apos;) ax.set_xlabel(&quot;data&quot;) ax.set_ylabel(&quot;target&quot;) ax.set_title(&quot;Decision Tree Regression&quot;) ax.legend(framealpha=0.5) plt.show() 结果： 可以看到，深度越小的决策树越简单，它将特征空间划分的折线越少。深度越深的决策树越复杂，它将特征空间划分的折线越多（越曲折）。 分类决策树(DecisionTreeClassifier) DecisionTreeClassifier实现了分类决策树，用于分类问题： 12345678910111213class sklearn.tree.DecisionTreeClassifier(criterion=&quot;gini&quot;, splitter=&quot;best&quot;, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0., max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0., min_impurity_split=None, class_weight=None, presort=False) 参数 criterion：字符串，指定切分质量的评价准则。 'gini'：切分时评价准则是Gini系数 'entropy'：切分时评价准则是熵 splitter：字符串，指定切分原则 'best'：选择最优的切分 'random'：随机切分 max_depth：指定树的最大深度 None：表示树的深度不限，直到每个叶子都是纯的，即叶节点中所有样本点都属于一个类，或者叶子中包含小于min_samples_split个样本点 min_samples_split：整数，指定每个内部节点（非叶节点）包含的最少的样本数 min_samples_leaf：整数，指定每个叶节点包含的最少样本数 min_weight_fraction_leaf：浮点数，叶节点中样本的最小权重系数 max_features：指定寻找best split时考虑的特征数量。如果已经考虑了max_features个特征，但是还没有找到一个有效的切分，那么还会继续寻找下一特征，直到找到一个有效的切分为止。 整数：每次切分只考虑max_features个特征 浮点数：每次切分只考虑max_features * n_features个特征（max_features指定了百分比） 'auto' 或者 'sqrt'：max_features = sqrt(n_features) 'log2'：max_features = log2(n_features) None：max_features = n_features random_state: 一个整数或者一个RandomState实例，或者None 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 max_leaf_nodes：指定叶节点的最大数量 None：此时叶节点数量不限 整数：则max_depth被忽略 presort：boolean，指定是否要提前排序数据从而加速寻找最优切分的过程。设置为True时，对于大数据集会减慢总体的训练过程，但是对于一个小数据集或者设定了最大深度的情况下，则会加速训练过程 class_weight：一个字典、字典的列表、'balance'或者None，指定了分类的权重。形式：{class_label: weight}。如果提供了sample_weight参数（fit方法提供），则这些权重都会乘以sample_weight。 None：每个分类权重都为1 'balance'：分类的权重是样本中各分类出现的频率的反比 属性 classes_：分类的标签值 feature_importances_：给出特征的重要程度。该值越高，则该特征越重要。（Gini importance） max_features_：max_features的推断值 n_classes_：给出分类的数量 n_features_：当执行fit之后，特征的数量 n_outputs_：当执行fit之后，输出的数量 tree_：一个Tree对象，即底层的决策树 方法 fit(X, y[, sample_weight, check_input, …]): 训练模型 predict(X[, check_input]): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 首先导入包 12345import matplotlib.pyplot as pltimport numpy as npfrom sklearn.tree import DecisionTreeClassifierfrom sklearn import model_selectionfrom sklearn import datasets 采用鸢尾花数据集。该数据集一共有150个数据，这些数据分为3类(setosa, versicolor, virginica)，每类50个数据。每个数据包含4个属性：sepal长度、sepal宽度、petal长度、petal宽度。 首先加载数据： 123456789def load_data(): &quot;&quot;&quot; 采用分层采样 :return: &quot;&quot;&quot; iris = datasets.load_iris() X_train = iris.data y_train = iris.target return model_selection.train_test_split(X_train, y_train, test_size=0.25, random_state=0, stratify=y_train) 然后，给出使用DecisionTreeClassifier进行分类的函数 123456def demo_DecisionTreeClassifier(*data): X_train, X_test, y_train, y_test = data clf = DecisionTreeClassifier() clf.fit(X_train, y_train) print(&quot;Training score: %f&quot; % clf.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % clf.score(X_test, y_test)) 执行结果： 12Training score: 1.000000Testing score: 0.973684 可以看到对训练数据集完全拟合，对测试数据集拟合精度高达97.3684%。 现在考察评价切分质量的评价准则criterion对于分类性能的影响： 123456789def demo_DecisionTreeClassifier_criterion(*data): X_train, X_test, y_train, y_test = data criterions = [&apos;gini&apos;, &apos;entropy&apos;] for criterion in criterions: clf = DecisionTreeClassifier(criterion=criterion) clf.fit(X_train, y_train) print(&quot;criterion: %s&quot; % criterion) print(&quot;Training score: %f&quot; % clf.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % clf.score(X_test, y_test)) 结果： 123456criterion: giniTraining score: 1.000000Testing score: 0.973684criterion: entropyTraining score: 1.000000Testing score: 0.921053 可以看到对于本问题二者对于训练集的拟合都非常完美，对应测试集的预测都较高，但是稍有不同，使用Gini系数的策略预测性能高。 接下来，检验随机划分与最优划分的影响： 123456789def demo_DecisionTreeClassifier_splitter(*data): X_train, X_test, y_train, y_test = data splitters = [&apos;best&apos;, &apos;random&apos;] for splitter in splitters: clf = DecisionTreeClassifier(splitter=splitter) clf.fit(X_train, y_train) print(&quot;splitter: %s&quot; % splitter) print(&quot;Training score: %f&quot; % clf.score(X_train, y_train)) print(&quot;Testing score: %f&quot; % clf.score(X_test, y_test)) 运行结果： 123456splitter: bestTraining score: 1.000000Testing score: 0.947368splitter: randomTraining score: 1.000000Testing score: 0.973684 最后考察决策树深度的影响： 1234567891011121314151617181920def demo_DecisionTreeClassifier_depth(*data, maxdepth): X_train, X_test, y_train, y_test = data depths = np.arange(1, maxdepth) training_scores = [] testing_scores = [] for depth in depths: clf = DecisionTreeClassifier(max_depth=depth) clf.fit(X_train, y_train) training_scores.append(clf.score(X_train, y_train)) testing_scores.append(clf.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(depths, training_scores, label=&quot;training score&quot;, marker=&apos;o&apos;) ax.plot(depths, testing_scores, label=&quot;testing score&quot;, marker=&apos;*&apos;) ax.set_xlabel(&quot;maxdepth&quot;) ax.set_ylabel(&quot;score&quot;) ax.set_title(&quot;Decision Tree Classification&quot;) ax.legend(framealpha=0.5, loc=&apos;best&apos;) plt.show() 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_DecisionTreeClassifier_depth(X_train, X_test, y_train, y_test, maxdepth=100) 运行结果： 可以看到随着树深度的增加，模型对训练集和预测集的拟合都在提高。这里训练数据集大小仅为150，不考虑任务条件，只需要一棵深度为\(\log_2150 ≤8\)的二叉树就能够完全拟合数据，使得每个叶子结点最多只有一个样本。考虑到决策树算法中的提前终止条件，则树的深度小于8。 决策图 当训练完一棵决策树时，可以通过sklearn.tree.export_graphviz(classifier, out_file)来将决策树转化成Graphviz格式的文件。对上面DecisionTreeClassifier例子，使用export_graphviz函数如下： 12345def demo_export_graphviz(*data, filename): X_train, X_test, y_train, y_test = data clf = DecisionTreeClassifier() clf.fit(X_train, y_train) export_graphviz(clf, filename) 调用： 12X_train, X_test, y_train, y_test = load_data()demo_export_graphviz(X_train, X_test, y_train, y_test, filename=&quot;out_DecisionTreeClassifier&quot;) 这里需要安装Graphviz程序。Graphviz是贝尔实验室开发的一个开源工具包，用于绘制结构化的图形网络。通过brew install graphviz安装。 然后通过Graphviz的dot工具，在终端中进入文件存放文件夹，然后运行命令dot -Tpng out_DecisionTreeClassifier -o out_DecisionTreeClassifier.png来生成png格式的决策图。其中-T指定了输出文件的格式，-o指定了输出文件名。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>decision tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Chapter-1 Linear Model]]></title>
    <url>%2F2019%2F07%2F24%2FMachineLearning-Chapter-1-Linear-Model%2F</url>
    <content type="text"><![CDATA[概述 对于样本\(\stackrel{\rightarrow}{x}\)，用列向量表示该样本\(\stackrel{\rightarrow}{x}={(x^{(1)},x^{(2)},…,x^{(n)})}^{T}\)。样本有\(n\)种特征，用\(x^{(i)}\)来表示样本的第\(i\)个特征。 线性模型(linear model)的形式为： \[f(\stackrel{\rightarrow}{x})=\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b\] 其中\(\stackrel{\rightarrow}{w}={(w^{(1)},w^{(2)},…,w^{(n)})}^{T}\)为每个特征对应的权重生成的权重向量。权重向量直观地表达了每个特征在预测中的重要性。 线性模型其实就是一系列一次特征的线性组合，在二维层面是一条直线，三维层面则是一个平面，以此类推到\(n\)维空间，这样可以理解为广义线性模型。 常见的广义线性模型包括岭回归、lasso回归、Elastic Net、逻辑回归、线性判别分析等。 算法 普通线性回归 线性回归是一种回归分析技术，回归分析本质上就是找出因变量和自变量之间的联系。回归分析的因变量应该是连续变量，如果因变量为离散变量，则问题转化为分类问题，回归分析是一个监督学习的问题。 给定数据集\(T=\{(\stackrel{\rightarrow}{x}_1,y_1),(\stackrel{\rightarrow}{x}_2,y_2),…,(\stackrel{\rightarrow}{x}_N,y_N)\}\), \(\stackrel{\rightarrow}{x}_i\in X\subseteq R^n\), \(\stackrel{\rightarrow}{y}_i\in Y\subseteq R\), \(i=1,2,…,N\)。其中\(\stackrel{\rightarrow}{x}={(x^{(1)},x^{(2)},…,x^{(n)})}^{T}\)。需要学习的模型为： \[f(\stackrel{\rightarrow}{x})=\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b\] 即：根据已知的数据集\(T\)来计算参数\(\stackrel{\rightarrow}{w}\)和\(b\)。 对于给定的样本\(\stackrel{\rightarrow}{x}_i\)，其预测值为\(\hat{y}_i=f(\stackrel{\rightarrow}{x}_i)=\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b\)。采用平方损失函数，在训练集\(T\)上，模型的损失函数为： \[L(f)=\sum_{i=1}^{N}(\hat{y}_i-y_i)^2=\sum_{i=1}^{N}(\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b-y_i)^2\] 我们的目标是损失函数最小化，即： \[(\stackrel{\rightarrow}{w}^*,b^*)=\arg\min_{\stackrel{\rightarrow}{w},b}\sum_{i=1}^{N}(\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b-y_i)^2\] 可以利用梯度下降法来求解上述最优化问题的数值解。在使用梯度下降法的时候，要注意特征归一化(Feature Scaling)，这也是许多机器学习模型都要注意的问题。特征归一化可以有效地提升模型的收敛速度和模型精度。 上述最优化问题实际上是有解析解的，可以用最小二乘法来求解解析解，该问题称为多元线性回归(multivariate linear regression)。 令： \[\vec{\tilde{w}}=(w^{(1)},w^{(2)},…,w^{(n)},b)^T=(\vec{w}^T,b)^T\\ \vec{\tilde{x}}=(x^{(1)},x^{(2)},…,x^{(n)},1)^T=(\vec{x}^T,1)^T\\ \vec{y}=(y_1,y_2,…,y_N)^T\] 则有： \[\sum_{i=1}^{N}(\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b-y_i)^2={(\vec{y}-(\vec{\tilde{x}}_1,\vec{\tilde{x}}_2,…,\vec{\tilde{x}}_N)^T\vec{\tilde{w}})}^T(\vec{y}-(\vec{\tilde{x}}_1,\vec{\tilde{x}}_2,…,\vec{\tilde{x}}_N)^T\vec{\tilde{w}})\] 令： \[\vec{x}=(\vec{\tilde{x}}_1,\vec{\tilde{x}}_2,…,\vec{\tilde{x}}_N)^T=\begin{bmatrix}\vec{\tilde{x}}_1^T\\\vec{\tilde{x}}_2^T\\…\\\vec{\tilde{x}}_N^T\end{bmatrix}=\begin{bmatrix}x_1^{(1)} &amp; x_1^{(2)} &amp; … &amp; x_1^{(n)} &amp; 1\\x_2^{(1)} &amp; x_2^{(2)} &amp; … &amp; x_2^{(n)} &amp; 1\\… &amp; … &amp; … &amp; … &amp; 1\\x_N^{(1)} &amp; x_N^{(2)} &amp; … &amp; x_N^{(n)} &amp; 1\end{bmatrix}\] 则： \[\vec{\tilde{w}}^*=\arg\min_{\vec{\tilde{w}}}(\vec{y}-\vec{x}\vec{\tilde{w}})^T(\vec{y}-\vec{x}\vec{\tilde{w}})\] 令\(E_{\vec{\tilde{w}}}=(\vec{y}-\vec{x}\vec{\tilde{w}})^T(\vec{y}-\vec{x}\vec{\tilde{w}})\)，求它的极小值。对\(\vec{\tilde{w}}\)求导令导数为零，得到解析解： \[\frac{\partial E_{\vec{\tilde{w}}}}{\partial \vec{\tilde{w}}}=2\vec{x}^T(\vec{x}\vec{\tilde{w}}-\vec{y})=\vec{0}\Longrightarrow \vec{x}^T\vec{x}\vec{\tilde{w}}=\vec{x}^T\vec{y}\] 当\(\vec{x}^T\vec{x}\)为满秩矩阵或者正定矩阵时，可得:\[\vec{\tilde{w}}^*=(\vec{x}^T\vec{x})^{-1}\vec{x}^T\vec{y}\]于是多元线性回归模型为：\[f(\vec{\tilde{x}}_i)=\vec{\tilde{x}}^T_i\vec{\tilde{w}}^*\] 当\(\vec{x}^T\vec{x}\)不是满秩矩阵时。比如\(N&lt;n\)（样本数量小于特征种类的数量），根据\(\vec{x}\)的秩小于等于\((N,n)\)中的最小值，即小于等于\(N\)（矩阵的秩一定小于等于矩阵的行数和列数）；而矩阵\(\vec{x}^T\vec{x}\)是\(n\times n\)大小的，它的秩一定小于等于\(N\)，因此不是满秩矩阵。此时存在多个解析解。常见的做法是引入正则化项，如\(L_1\)正则化或者\(L_2\)正则化，以\(L_2\)正则化为例：\[\vec{\tilde{w}}^*=\arg\min_{\vec{\tilde{w}}}[(\vec{y}-\vec{x}\vec{\tilde{w}})^T(\vec{y}-\vec{x}\vec{\tilde{w}})+\lambda||\vec{\tilde{w}}||_2^2]\]其中，\(\lambda &gt;0\)调整正则化项与均方误差的比例；\(||…||_2\)为\(L_2\)范数。 根据上述原理，我们得到多元线性回归算法： 输入：数据集 \(T=\{(\stackrel{\rightarrow}{x}_1,y_1),(\stackrel{\rightarrow}{x}_2,y_2),…,(\stackrel{\rightarrow}{x}_N,y_N)\}\), \(\stackrel{\rightarrow}{x}_i\in X\subseteq R^n\), \(\stackrel{\rightarrow}{y}_i\in Y\subseteq R\), \(i=1,2,…,N\)，正则化项系数\(\lambda &gt;0\)。 输出：\[f(\stackrel{\rightarrow}{x})=\stackrel{\rightarrow}{w}·\stackrel{\rightarrow}{x}+b\] 算法步骤： 令：\[\vec{\tilde{w}}=(w^{(1)},w^{(2)},…,w^{(n)},b)^T=(\vec{w}^T,b)^T\\\vec{\tilde{x}}=(x^{(1)},x^{(2)},…,x^{(n)},1)^T=(\vec{x}^T,1)^T\\\vec{y}=(y_1,y_2,…,y_N)^T\]计算\[\vec{x}=(\vec{\tilde{x}}_1,\vec{\tilde{x}}_2,…,\vec{\tilde{x}}_N)^T=\begin{bmatrix}\vec{\tilde{x}}_1^T\\\vec{\tilde{x}}_2^T\\…\\\vec{\tilde{x}}_N^T\end{bmatrix}=\begin{bmatrix}x_1^{(1)} &amp; x_1^{(2)} &amp; … &amp; x_1^{(n)} &amp; 1\\x_2^{(1)} &amp; x_2^{(2)} &amp; … &amp; x_2^{(n)} &amp; 1\\… &amp; … &amp; … &amp; … &amp; 1\\x_N^{(1)} &amp; x_N^{(2)} &amp; … &amp; x_N^{(n)} &amp; 1\end{bmatrix}\] 求解：\[\vec{\tilde{w}}^*=\arg\min_{\vec{\tilde{w}}}[(\vec{y}-\vec{x}\vec{\tilde{w}})^T(\vec{y}-\vec{x}\vec{\tilde{w}})+\lambda||\vec{\tilde{w}}||_2^2]\] 最终得到模型：\[f(\vec{\tilde{x}}_i)=\vec{\tilde{x}}^T_i\vec{\tilde{w}}^*\] 广义线性模型 考虑单调可导函数\(h(·)\)，令\(h(y)=\vec{w}^T\vec{x}+b\)，这样得到的模型称为广义线性模型(generalized linear model)。 广义线性模型的一个典型例子就是对数线性回归。当\(h(·)=\ln{(·)}\)时当广义线性模型就是对数线性回归，即\[\ln{y}=\vec{w}^T\vec{x}+b\] 它是通过\(\exp(\vec{w}^T\vec{x}+b)\)拟合\(y\)的。它虽然称为广义线性回归，但实质上是非线性的。 逻辑回归 上述内容都是在用线性模型进行回归学习，而线性模型也可以用于分类。考虑二类分类问题，给定数据集\(T=\{(\stackrel{\rightarrow}{x}_1,y_1),(\stackrel{\rightarrow}{x}_2,y_2),…,(\stackrel{\rightarrow}{x}_N,y_N)\}\), \(\stackrel{\rightarrow}{x}_i\in X\subseteq R^n\), \(\stackrel{\rightarrow}{y}_i\in Y=\{0,1\},\)\(i=1,2,…,N\)，其中\(\stackrel{\rightarrow}{x}_i={(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})}^{T}\)。我们需要知道\(P(y/ \vec{x})\)，这里用条件概率的原因是：预测的时候都是已知\(\vec{x}\)，然后需要判断此时对应的\(y\)值。 考虑到\(\vec{w}·\vec{x}+b\)取值是连续的，因此它不能拟合离散变量。可以考虑用它来拟合条件概率\(P(y/\vec{x})\)，因为概率的取值也是连续的。但是对于\(\vec{w}\neq \vec{0}\)（若等于零向量则没有求解的价值），\(\vec{w}·\vec{x}+b\)的取值是从\(-\infty \thicksim +\infty\)，不符合概率取值为\(0\thicksim 1\)，因此考虑采用广义线性模型，最理想的是单位阶跃函数：\[P(y=1/\vec{x})=\left\{\begin{aligned}0,z&lt;0\\0.5,z=0\\1,z&gt;0\end{aligned}\right.,z=\vec{w}·\vec{x}+b\] 但是阶跃函数不满足单调可导的性质，退而求其次，我们需要找一个可导的、与阶跃函数相似的函数。对数概率函数(logistic function)就是这样一个替代函数：\[P(y=1/\vec{x})=\frac{1}{1+e^{-z}},z=\vec{w}·\vec{x}+b\] 由于\(P(y=0/\vec{x})=1-P(y=1/\vec{x})\)，则有：\(\ln{\frac{P(y=1/\vec{x})}{P(y=0/\vec{x})}}=z=\vec{w}·\vec{x}+b\)。比值\(\frac{P(y=1/\vec{x})}{P(y=0/\vec{x})}\)表示样本为正例的可能性比反例的可能性，称为概率(odds)，反映样本作为正例的相对可能性。概率大对数称为对数概率(log odds，也称为logit)。 下面给出逻辑回归模型参数估计：给定训练数据集\(T=\{(\stackrel{\rightarrow}{x}_1,y_1),(\stackrel{\rightarrow}{x}_2,y_2),…,(\stackrel{\rightarrow}{x}_N,y_N)\}\)，其中\(\vec{x}_i \in R^n,y_i \in \{0,1\}\)。模型估计的原理：用极大似然估计法估计模型参数。 为了便于讨论，我们将参数\(b\)吸收进\(\vec{w}\)中，令：\[\vec{\tilde{w}}={(w^{(1)},w^{(2)},…,w^{(n)},b)}^{T}\in R^{n+1}\\\vec{\tilde{x}}={(x^{(1)},x^{(2)},…,x^{(n)},1)}^{T}\in R^{n+1}\] 令\(P(Y=1/\vec{\tilde{x}})=\pi (\vec{\tilde{x}})=\frac{\exp (\vec{\tilde{w}}·\vec{\tilde{x}})}{1+\exp (\vec{\tilde{w}}·\vec{\tilde{x}})}\),\(P(Y= 0/\vec{\tilde{x}})=1-\pi (\vec{\tilde{x}})\)，则似然函数为：\[\prod_{i=1}^N[\pi (\vec{\tilde{x}}_i)]^{y_i}[1-\pi (\vec{\tilde{x}}_i)]^{1-y_i}\] 对数似然函数为：\[L(\vec{\tilde{w}})=\sum_{i=1}^N[y_i\log \pi (\vec{\tilde{x}}_i)+(1-y_i)\log (1-\pi (\vec{\tilde{x}}_i)]\\=\sum_{i=1}^N[y_i\log \frac{\pi (\vec{\tilde{x}}_i)}{1-\pi (\vec{\tilde{x}}_i)}+\log(1-\pi (\vec{\tilde{x}}_i))]\] 又由于\(\pi (\vec{\tilde{x}}_i)=\frac{\exp (\vec{\tilde{w}}·\vec{\tilde{x}})}{1+\exp (\vec{\tilde{w}}·\vec{\tilde{x}})}\)，因此：\[L(\vec{\tilde{w}})=\sum_{i=1}^N[y_i(\vec{\tilde{w}}·\vec{\tilde{x}}_i)-\log (1+\exp(\vec{\tilde{w}}·\vec{\tilde{x}}_i))]\] 对\(L(\vec{\tilde{w}})\)求极大值，得到\(\vec{\tilde{w}}\)的估计值。设估计值为\(\vec{\tilde{w}}^{*}\)，则逻辑回归模型为：\[P(Y=1/X=\vec{\tilde{x}})=\frac{\exp (\vec{\tilde{w}}^{*} ·\vec{\tilde{x}})}{1+\exp(\vec{\tilde{w}}^{*}·\vec{\tilde{x}})}\\P(Y=0/X=\vec{\tilde{x}})=\frac{1}{1+\exp(\vec{\tilde{w}}^{*}·\vec{\tilde{x}})}\] 通常用梯度下降法或者拟牛顿法来求解该最大值问题 以上讨论的都是二类分类的逻辑回归模型，可以推广到多类分类逻辑回归模型。设离散性随机变量Y的取值集合为：\(\{1,2,…,K\}\)，则多类分类逻辑回归模型为：\[P(Y=k/\vec{\tilde{x}})=\frac{\exp (\vec{\tilde{w}}_k ·\vec{\tilde{x}})}{1+\sum_{k=1}^{K-1}\exp(\vec{\tilde{w}}_k·\vec{\tilde{x}})},k=1,2,…,K-1\\P(Y=K/\vec{\tilde{x}})=\frac{1}{1+\sum_{k=1}^{K-1}\exp(\vec{\tilde{w}}_k·\vec{\tilde{x}})},\vec{\tilde{x}}\in R^{n+1},\vec{\tilde{w}}_k\in R^{n+1}\] 其参数估计方法类似二类分类逻辑回归模型。 线性判别分析 线性判别分析(Linear Discriminant Analysis, LDA)的思想： 训练时：设法将训练样本投影到一条直线上，使得同类样本的投影点尽可能地接近、异类样本的投影点尽可能地远离。要学习的就是这样一条直线。 预测时：将待预测样本投影到学习到直线上，根据它的投影点的位置来判定它的类别。 考虑二类分类问题，给定数据集\(T=\{(\stackrel{\rightarrow}{x}_1,y_1),(\stackrel{\rightarrow}{x}_2,y_2),…,(\stackrel{\rightarrow}{x}_N,y_N)\}\), \(\stackrel{\rightarrow}{x}_i\in X\subseteq R^n\), \(\stackrel{\rightarrow}{y}_i\in Y=\{0,1\}\), \(i=1,2,…,N\)，其中\(\stackrel{\rightarrow}{x}_i={(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})}^{T}\)。 设\(T_0\)表示类别为0的样例的集合，这些样例的均值向量为\(\stackrel{\rightarrow}{\mu}_0={(\mu_0^{(1)},\mu_0^{(2)},…,\mu_0^{(n)})}^{T}\)，这些样例的特征之间协方差矩阵为\(\sum_0\)（协方差矩阵大小为\(n\times n\)）。 设\(T_1\)表示类别为1的样例的集合，这些样例的均值向量为\(\stackrel{\rightarrow}{\mu}_1={(\mu_1^{(1)},\mu_1^{(2)},…,\mu_1^{(n)})}^{T}\)，这些样例的特征之间协方差矩阵为\(\sum_1\)（协方差矩阵大小为\(n\times n\)）。 假定直线为\(y=\vec{w}^T\vec{x}\)（这里省略了\(b\)，因为考察的是样本点在直线上的投影，总可以平行移动直线到原点而保持投影不变，此时\(b=0\)），其中\(\stackrel{\rightarrow}{w}={(w^{(1)},w^{(2)},…,w^{(n)})}^{T}\),\(\stackrel{\rightarrow}{x}={(x^{(1)},x^{(2)},…,x^{(n)})}^{T}\) 将数据投影到直线上，则 两类样本的中心在直线上的投影分别为\(\vec{w}^T\vec{\mu}_0\)和\(\vec{w}^T\vec{\mu}_1\)。 两类样本投影的方差分别为\(\vec{w}^T\sum_0\vec{w}\)和\(\vec{w}^T\sum_1\vec{w}\)。 我们的目标是：同类样本的投影点尽可能地接近、异类样本点投影点尽可能地远离。那么可以使同类样例投影点点方差尽可能地小，即\(\vec{w}^T\sum_0\vec{w}+\vec{w}^T\sum_1\vec{w}\)尽可能地小；可以使异类样例的中心的投影点尽可能地远，即\(||\vec{w}^T\vec{\mu}_0-\vec{w}^T\vec{\mu}_1||_2^2\)尽可能地大。于是得到最大化的目标：\[J=\frac{||\vec{w}^T\vec{\mu}_0-\vec{w}^T\vec{\mu}_1||_2^2}{\vec{w}^T\sum_0\vec{w}+\vec{w}^T\sum_1\vec{w}}=\frac{\vec{w}^T(\vec{\mu}_0-\vec{\mu}_1)(\vec{\mu}_0-\vec{\mu}_1)^T\vec{w}}{\vec{w}^T(\sum_0+\sum_1)\vec{w}}\] 定义类内散度矩阵(within-class scatter matrix)：\[S_w={\sum}_0+{\sum}_1=\sum_{\vec{x}\in T_0}(\vec{x}-\vec{\mu}_0)(\vec{x}-\vec{\mu}_0)^T+\sum_{\vec{x}\in T_1}(\vec{x}-\vec{\mu}_1)(\vec{x}-\vec{\mu}_1)^T\] 定义类间散度矩阵(between-class scatter matrix)：\(S_b=(\vec{\mu}_0-\vec{\mu}_1)(\vec{\mu}_0-\vec{\mu}_1)^T\)，它是向量\((\vec{\mu}_0-\vec{\mu}_1)\)与它自身的外积，则LDA最大化的目标为：\[J=\frac{\vec{w}^TS_b\vec{w}}{\vec{w}^TS_w\vec{w}}\] \(J\)也称为\(S_b\)与\(S_w\)的广义瑞利商。现在求解最优化问题：\[\vec{w}^*=\arg \max_{\vec{w}}\frac{\vec{w}^TS_b\vec{w}}{\vec{w}^TS_w\vec{w}}\] 由于分子与分母都是关于\(\vec{w}\)的二次项，因此上式的解与\(\vec{w}\)的长度无关。令\(\vec{w}^TS_w\vec{w}=1\)，则最优化问题改写为：\[\vec{w}^*=\arg \min_{\vec{w}}-\vec{w}^TS_b\vec{w}\\s.t.\vec{w}^TS_w\vec{w}=1\] 应用拉格朗日乘子法：\[S_b\vec{w}=\lambda S_w\vec{w}\] 令\((\vec{\mu}_0-\vec{\mu}_1)^T\vec{w}=\lambda_{\vec{w}}\)，其中\(\lambda_{\vec{w}}\)为实数。则\[S_b\vec{w}=(\vec{\mu}_0-\vec{\mu}_1)(\vec{\mu}_0-\vec{\mu}_1)^T\vec{w}=\lambda_{\vec{w}}(\vec{\mu}_0-\vec{\mu}_1)=\lambda S_w\vec{w}\] 由于与\(\vec{w}\)的长度无关，可以令\(\lambda_{\vec{w}}=\lambda\)，则有：\[(\vec{\mu}_0-\vec{\mu}_1)=S_w\vec{w}\Longrightarrow \vec{w}=S_w^{-1}(\vec{\mu}_0-\vec{\mu}_1)\] 上述讨论的是二类分类LDA算法。可以将它推广到多分类任务中：假定存在\(M\)个类，属于第\(i\)个类的样本的集合为\(T_i\)，\(T_i\)中的样例数为\(m_i\)，则有：\(\sum_{i=1}^Mm_i=N\)，其中\(N\)为样本总数。设\(T_i\)表示类别为\(i，i=1,2,…,M\)的样例的集合，这些样例的均值向量为：\[\vec{\mu}_i=(\mu_i^{(1)},\mu_i^{(2)},…,\mu_i^{(n)})^T=\frac{1}{m_i}\sum_{\vec{x}_i\in T_i}\vec{x}_i\] 这些样例的特征之间协方差矩阵为\(\sum_i\)（协方差矩阵大小为\(n\times n\)）。定义\(\vec{\mu}=(\mu^{(1)},\mu^{(2)},…,\mu^{(n)})^T=\frac{1}{N}\sum_{i=1}^N\vec{x}_i\)是所有样例的均值向量。 要使得同类样例的投影点尽可能地接近，则可以使同类样例投影点的方差尽可能地小，因此定义类别的类内散度矩阵为\(S_{wi}=\sum_{\vec{x}\in T_i}(\vec{x}-\vec{\mu}_i)(\vec{x}-\vec{\mu}_i)^T\)；定义类内散度矩阵为\(S_w=\sum_{i=1}^MS_{wi}\)。 类别的类内散度矩阵为\(S_{wi}=\sum_{\vec{x}\in T_i}(\vec{x}-\vec{\mu}_i)(\vec{x}-\vec{\mu}_i)^T\)，实际上就等于样本集\(T_i\)的协方差矩阵\(\sum_i\)。 要使异类样例的投影点尽可能地远，则可以使异类样例中心的投影点尽可能地远，由于这里不止两个中心点，因此不能简单地套用二类LDA的做法（即两个中心点的距离）。这里用每一类样本集的中心点距和总的中心点的距离作为度量。考虑到每一类样本集的大小可能不同（密度分布不均），故我们对这个距离加以权重，因此定义类间散度矩阵\(S_b=\sum_{i=1}^Mm_i(\vec{\mu}_i-\vec{\mu})(\vec{\mu}_i-\vec{\mu})^T\)。 \((\vec{\mu}_i-\vec{\mu})(\vec{\mu}_i-\vec{\mu})^T\)也是一个协方差矩阵，它刻画的是第\(i\)类与总体之间的关系。 设\(W\in R^{n\times (M-1)}\)是投影矩阵。经过推导可以得到最大化的目标：\[J=\frac{tr(W^TS_bW)}{tr(W^TS_wW)}\] 其中\(tr(.)\)表示矩阵的迹。一个矩阵的迹是矩阵对角线的元素之和，它是一个矩阵的不变量，也等于所有特征值之和。 还有一个常用的矩阵不变量是矩阵的行列式，它等于矩阵的所有特征值之积。 多分类LDA将样本投影到\(M-1\)维空间，因此它是一种经典的监督降维技术。 Python实战 123import matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_model, discriminant_analysis, model_selection 在线性回归问题中，数据集使用了scikit-learn自带的一个数据集。该数据集有442个样本；每个样本有10个特征；每个特征都是浮点数，数据都在-0.2～0.2之间；样本的目标在整数25～346之间。 12345678def load_data(): &quot;&quot;&quot; 加载数据集并随机切分数据集为两个部分，其中test_size指定了测试集为原始数据集的大小/比例 :return: list：训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 &quot;&quot;&quot; diabetes = datasets.load_diabetes() return model_selection.train_test_split(diabetes.data, diabetes.target, test_size=0.25, random_state=0) 线性回归模型 LinearRegression是scikit-learn提供的线性回归模型 1class sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=Fasle, copy_X=True, n_jobs=1) 参数 fit_intercept : boolean, optional, default True. 指定是否需要计算b值, 如果为False则不计算b值。 normalize : boolean, optional, default False. 如果为True，那么训练样本会在回归之前被归一化。 copy_X : boolean, optional, default True. 如果为True，则会复制X。 n_jobs : int or None, optional (default=None). 任务并行时指定的CPU数量，如果为-1则使用所有可用的CPU。 属性 coef_ : 权重向量 intercept_ : b值 方法 fit(X, y[, sample_weight]): 训练模型 predict(X): 用模型进行预测，返回预测值 score(X, y[, sample_weight]): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 12345678910111213def demo_LinearRegression(*data): &quot;&quot;&quot; 使用LinearRegression函数 :param data: 训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 :return: 权重向量、b值，预测结果的均方误差，预测性能得分 &quot;&quot;&quot; X_train, X_test, y_train, y_test = data regr = linear_model.LinearRegression() regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %.2f&apos; % regr.intercept_) print(&apos;Residual sum of squares: %.2f&apos; % np.mean((regr.predict(X_test) - y_test) ** 2)) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 该函数简单地从训练数据集中学习，然后从测试数据中预测。调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_LinearRegression(X_train, X_test, y_train, y_test) 输出结果如下： 12345Coefficients: [ -43.26774487 -208.67053951 593.39797213 302.89814903 -560.27689824 261.47657106 -8.83343952 135.93715156 703.22658427 28.34844354]Intercept: 153.07Residual sum of squares: 3180.20Score: 0.36 可以看到测试集中预测结果的均方误差为3180.20，预测性能得分仅为0.36。 线性回归模型的正则化 前面理论部分提到对于多元线性回归，当\(\vec{x}^T\vec{x}\)不是满秩矩阵时存在多个解析解，它们都能使得均方误差最小化，常见的做法是引入正则化项。所谓正则化，就是对模型的参数添加一些先验假设，控制模型空间，以达到使得模型复杂度较小的目的。岭回归和LASSO是目前最流行的两种线性回归正则化方法。根据不同的正则化方式，有不同的方法： Ridge Regression: 正则化项为：\(\alpha ||\vec{w}||_2^2,\alpha &gt;0\)。 Lasso Regression: 正则化项为：\(\alpha ||\vec{w}||_1, \alpha &gt;0\)。 Elastic Net: 正则化项为：\(\alpha \rho ||\vec{w}||_1+\frac{\alpha (1-\rho )}{2}||\vec{w}||_2^2,\alpha &gt;0,1\ge\rho \ge 0\)。 其中，正则项系数\(\alpha\)的选择很关键，初始值建议一开始设置为0，先确定一个比较好的learning rate，然后固定该learning rate，给\(\alpha\)一个值（比如1.0），然后根据validation accuracy将\(\alpha\)增大或者缩小10倍（增减10倍为粗调节，当你确定了\(\alpha\)合适的数量级后，比如\(\alpha=0.01\)，再进一步细调节为0.02、0.03、0.0009等）。 岭回归 岭回归(Ridge Regression)是一种正则化方法，通过值损失函数中加入\(L_2\)范数惩罚项，来控制线性模型的复杂程度，从而使得模型更稳健。Ridge类实现了岭回归模型，其原型为： 12class sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=&apos;auto, random_state=None) 参数 alpha: \(\alpha\)值，其值越大则正则化项的占比越大。 fit_intercept: boolean，指定是否需要计算b值。 max_iter: 一个整数，指定最大迭代次数。如果为None则为默认值，不同solver的默认值不同。 normalize: boolean，如果为True，那么训练样本会在回归之前被归一化。 copy_X: boolean，如果为True，则会复制X。 solver: 一个字符串，指定求解最优化问题的算法。 auto: 根据数据集自动选择算法 svd: 使用奇异值分解来计算回归系数 cholesky: 使用scipy.linalg.solve函数来求解 sparse_cg: 使用scipy.sparse.linalg.cg函数来求解 lsqr: 使用scipy.sparse.linalg.lsqr函数来求解，运算速度最快 sag: 使用Stochastic Average Gradient descent算法求解最优化问题 tol: 一个浮点数，指定判断迭代收敛与否的阈值。 random_state: 一个整数或者一个RandomState实例，或者None；在solver=sag时使用 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 属性 coef_: 权重向量 intercept_: b值 n_iter_: 实际迭代次数 方法 fit(X, y[, sample_weight]): 训练模型 predict(X): 用模型进行预测，返回预测值 score(X, y[, sample_weight]): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 12345678910111213def demo_Ridge(*data): &quot;&quot;&quot; 使用Ridge函数 :param data: 训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 :return: 权重向量、b值，预测结果的均方误差，预测性能得分 &quot;&quot;&quot; X_train, X_test, y_train, y_test = data regr = linear_model.Ridge() regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %.2f&apos; % regr.intercept_) print(&apos;Residual sum of squares: %.2f&apos; % np.mean((regr.predict(X_test) - y_test) ** 2)) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 该函数简单地从训练数据集中学习，然后从测试数据集中预测。这里的Ridge的所有参数都采用默认值。调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_Ridge(X_train, X_test, y_train, y_test) 输出结果如下： 12345Coefficients: [ 21.19927911 -60.47711393 302.87575204 179.41206395 8.90911449 -28.8080548 -149.30722541 112.67185758 250.53760873 99.57749017]Intercept: 152.45Residual sum of squares: 3192.33Score: 0.36 可以看到测试集中预测结果的均方误差为3192.33，预测性能得分仅为0.36。 下面检验不同的\(\alpha\)值对于预测性能的影响，给出测试函数： 1234567891011121314151617def demo_Ridge_alpha(*data): X_train, X_test, y_train, y_test = data alphas = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000] scores = [] for i, alpha in enumerate(alphas): regr = linear_model.Ridge(alpha=alpha) regr.fit(X_train, y_train) scores.append(regr.score(X_test, y_test)) ## 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(alphas, scores) ax.set_xlabel(r&quot;$\alpha$&quot;) ax.set_ylabel(r&quot;score&quot;) ax.set_xscale(&apos;log&apos;) ax.set_title(&quot;Ridge&quot;) plt.show() 为了便于观察结果，将\(x\)轴设置为了对数坐标。调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_Ridge_alpha(X_train, X_test, y_train, y_test) 输出结果如下图所示： 可以看到，当\(\alpha\)超过1之后，随着\(\alpha\)的增长，预测性能急剧下降。这是因为\(\alpha\)较大时，正则化项影响较大，模型趋于简单。 Lasso回归 Lasso回归和岭回归的区别就在于它的惩罚项是基于L1范数，因此它可以将系数控制收缩到0，从而达到变量选择的效果。Lasso类实现了Lasso回归模型： 1234class sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=1e-4, warm_start=False, positive=False, random_state=None, selection=&apos;cyclic&apos;) 参数 alpha: \(\alpha\)值，其值越大则正则化项的占比越大。 fit_intercept: boolean，指定是否需要计算b值。 max_iter: 一个整数，指定最大迭代次数。如果为None则为默认值，不同solver的默认值不同。 normalize: boolean，如果为True，那么训练样本会在回归之前被归一化。 copy_X: boolean，如果为True，则会复制X。 precompute: boolean/序列。决定是否提前计算Gram矩阵来加速计算。 tol: 一个浮点数，指定判断迭代收敛与否的阈值。 warm_start: boolean，如果为True，那么使用前一次训练结果继续训练。否则从头开始训练。 positive: boolean，如果为True，那么强制要求权重向量的分量都为正数。 selection: 一个字符串，指定了每轮迭代时选择权重向量的哪个分量来更新。 random: 随机选择权重向量的一个分量来更新 cyclic: 从前向后依次选择权重向量的一个分量来更新 random_state: 一个整数或者一个RandomState实例，或者None；在solver=sag时使用 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 属性 coef_: 权重向量 intercept_: b值 n_iter_: 实际迭代次数 方法 fit(X, y[, sample_weight]): 训练模型 predict(X): 用模型进行预测，返回预测值 score(X, y[, sample_weight]): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 12345678910111213def demo_Lasso(*data): &quot;&quot;&quot; 使用Lasso函数 :param data: 训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 :return: 权重向量、b值，预测结果的均方误差，预测性能得分 &quot;&quot;&quot; X_train, X_test, y_train, y_test = data regr = linear_model.Lasso() regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %.2f&apos; % regr.intercept_) print(&apos;Residual sum of squares: %.2f&apos; % np.mean((regr.predict(X_test) - y_test) ** 2)) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_Lasso(X_train, X_test, y_train, y_test) 输出结果： 12345Coefficients: [ 0. -0. 442.67992538 0. 0. 0. -0. 0. 330.76014648 0. ]Intercept: 152.52Residual sum of squares: 3583.42Score: 0.28 下面检验不同的\(\alpha\)值对于预测性能的影响： 1234567891011121314151617def demo_Lasso_alpha(*data): X_train, X_test, y_train, y_test = data alphas = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000] scores = [] for i, alpha in enumerate(alphas): regr = linear_model.Lasso(alpha=alpha) regr.fit(X_train, y_train) scores.append(regr.score(X_test, y_test)) ## 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(alphas, scores) ax.set_xlabel(r&quot;$\alpha$&quot;) ax.set_ylabel(r&quot;score&quot;) ax.set_xscale(&apos;log&apos;) ax.set_title(&quot;Lasso&quot;) plt.show() 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_Lasso_alpha(X_train, X_test, y_train, y_test) 输出结果如下： 可以看出，当\(\alpha\)超过1之后，随着\(\alpha\)的增长，预测性能急剧下降。 ElasticNet回归 ElasticNet回归是对Lasso回归和岭回归的融合，其惩罚项是L1范数和L2范数的一个权衡。ElasticNet类实现了ElasticNet回归： 1234class sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=1e-4, warm_start=False, positive=False, random_state=None, selection=&apos;cyclic&apos;) 参数 alpha: \(\alpha\)值。 l1_ratio: \(\rho\)值。 fit_intercept: boolean，指定是否需要计算b值。 max_iter: 一个整数，指定最大迭代次数。如果为None则为默认值，不同solver的默认值不同。 normalize: boolean，如果为True，那么训练样本会在回归之前被归一化。 copy_X: boolean，如果为True，则会复制X。 precompute: boolean/序列。决定是否提前计算Gram矩阵来加速计算。 tol: 一个浮点数，指定判断迭代收敛与否的阈值。 warm_start: boolean，如果为True，那么使用前一次训练结果继续训练。否则从头开始训练。 positive: boolean，如果为True，那么强制要求权重向量的分量都为正数。 selection: 一个字符串，指定了每轮迭代时选择权重向量的哪个分量来更新。 random: 随机选择权重向量的一个分量来更新 cyclic: 从前向后依次选择权重向量的一个分量来更新 random_state: 一个整数或者一个RandomState实例，或者None；在solver=sag时使用 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 属性 coef_: 权重向量 intercept_: b值 n_iter_: 实际迭代次数 方法 fit(X, y[, sample_weight]): 训练模型 predict(X): 用模型进行预测，返回预测值 score(X, y[, sample_weight]): 返回预测性能得分 设预测集为\(T_{test}\)，真实值为\(y_i\)，真实值的均值为\(\overline{y}\)，预测值为\(\hat{y}_i\)，则：\[score=1-\frac{\sum_{T_{test}}(y_i-\hat{y}_i)^2}{(y_i-\overline{y})^2}\] score不超过1，但是可能为负值（预测效果太差）。 score越大，预测性能越好。 12345678910111213def demo_ElasticNet(*data): &quot;&quot;&quot; 使用ElasticNet函数 :param data: 训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 :return: 权重向量、b值，预测结果的均方误差，预测性能得分 &quot;&quot;&quot; X_train, X_test, y_train, y_test = data regr = linear_model.ElasticNet() regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %.2f&apos; % regr.intercept_) print(&apos;Residual sum of squares: %.2f&apos; % np.mean((regr.predict(X_test) - y_test) ** 2)) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_ElasticNet(X_train, X_test, y_train, y_test) 输出结果如下： 12345Coefficients: [ 0.40560736 0. 3.76542456 2.38531508 0.58677945 0.22891647 -2.15858149 2.33867566 3.49846121 1.98299707]Intercept: 151.93Residual sum of squares: 4922.36Score: 0.01 下面检验不同$,$值对预测性能的影响： 12from mpl_toolkits.mplot3d import Axes3Dfrom matplotlib import cm 12345678910111213141516171819202122def demo_ElasticNet_alpha_rho(*data): X_train, X_test, y_train, y_test = data alphas = np.logspace(-2, 2) rhos = np.linspace(0.01, 1) scores = [] for alpha in alphas: for rho in rhos: regr = linear_model.ElasticNet(alpha=alpha, l1_ratio=rho) regr.fit(X_train, y_train) scores.append(regr.score(X_test, y_test)) ## 绘图 alphas, rhos = np.meshgrid(alphas, rhos) scores = np.array(scores).reshape(alphas.shape) fig = plt.figure() ax = Axes3D(fig) surf = ax.plot_surface(alphas, rhos, scores, rstride=1, cstride=1, cmap=cm.jet, linewidth=0, antialiased=False) fig.colorbar(surf, shrink=0.5, aspect=5) ax.set_xlabel(r&quot;$\alpha$&quot;) ax.set_ylabel(r&quot;$\rho$&quot;) ax.set_zlabel(&quot;score&quot;) ax.set_title(&quot;ElasticNet&quot;) plt.show() 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_ElasticNet_alpha_rho(X_train, X_test, y_train, y_test) 输出结果如下： 可以看到随着\(\alpha\)的增大，预测性能下降，而\(\rho\)影响的是性能下降的速度。 逻辑回归 在scikit-learn中，LogisticRegression实现了逻辑回归功能： 12345class sklearn.linear_model.LogisticRegression(penalty=&apos;l2&apos;, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=&apos;warn&apos;, max_iter=100, multi_class=&apos;warn&apos;, verbose=0, warm_start=False, n_jobs=None, l1_ratio=None) 参数 penalty: 一个字符串，指定了正则化策略 l2: 则优化目标函数为：\(\frac{1}{2}||\vec{w}||_2^2+CL(\vec{w}),C&gt;0\)，\(L(\vec{w})\)为极大似然函数 l1: 则优化目标函数为：\(||\vec{w}||_1 +CL(\vec{w}),C&gt;0\)，\(L(\vec{w})\)为极大似然函数 dual: boolean，如果为True，则求解对偶形式（只在penalty='l2'且solver='liblinear'有对偶形式）；如果为False，则求解原始形式。 C: 一个浮点数，指定了罚项系数的倒数，值越小正则化项越大。 fit_intercept: boolean，指定是否需要计算b值。 intercept_scaling: 一个浮点数，只当solver='liblinear'时有意义。当采用fit_intercept时，相当于人造一个特征出来，该特征恒为1，其权重为b。在计算正则化项时，该人造特征也被考虑了，因此为了降低这个人造特征的影响，需要提供intercept_scaling。 class_weight: 一个字典或者字符串 字典：字典给出每个分类的权重，如{class_label: weight} ‘balanced'：每个分类的权重与该分类在样本集中出现的频率成反比 未指定：每个分类的权重都为1 max_iter: 一个整数，指定最大迭代次数。 random_state: 一个整数或者一个RandomState实例，或者None；在solver=sag时使用 如果为整数，则它指定了随机数生成器的种子 如果为RandomState实例，则指定例随机数生成器 如果为None，则使用默认的随机数生成器 solver: 一个字符串，指定了求解最优化问题的算法 newton-cg: 使用牛顿法，只处理penalty='l2'的情况 lbfgs: 使用L-BFGS拟牛顿法，只处理penalty='l2'的情况 liblinear: 使用liblinear，适用规模小的数据集 sag: 使用Stochastic Average Gradient descent算法，适用规模大的数据集，只处理penalty='l2'的情况 tol: 一个浮点数，指定判断迭代收敛与否的阈值。 multi_class: 一个字符串，指定对于多分类问题的策略 ovr: 采用one-vs-rest策略 multinomial: 直接采用多分类逻辑回归策略 verbose: 一个正数，用于开启/关闭迭代中间输出日志功能。 warm_start: boolean，如果为True，那么使用前一次训练结果继续训练。否则从头开始训练。 n_jobs: 一个正数，指定任务并行时的CPU数量。如果为-1则使用所有可用的CPU。 属性 coef_: 权重向量 intercept_: b值 n_iter_: 实际迭代次数 方法 fit(X, y[, sample_weight]): 训练模型 predict(X): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 为了使用逻辑回归模型，我们对鸢尾花进行分类。该数据集一共有150个数据，这些数据分为3类(setosa, versicolor, virginica)，每类50个数据。每个数据包含4个属性：sepal长度、sepal宽度、petal长度、petal宽度 首先加载数据： 123456789def load_data(): &quot;&quot;&quot; 采用分层采样 :return: &quot;&quot;&quot; iris = datasets.load_iris() X_train = iris.data y_train = iris.target return model_selection.train_test_split(X_train, y_train, test_size=0.25, random_state=0, stratify=y_train) 123456789101112def demo_LogisticRegression(*data): &quot;&quot;&quot; 使用LogisticRegression函数 :param data: 训练样本集、测试样本集、训练样本集对应的标签值、测试样本集对应的标签值 :return: 权重向量、b值，预测性能得分 &quot;&quot;&quot; X_train, X_test, y_train, y_test = data regr = linear_model.LogisticRegression() regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %s&apos; % regr.intercept_) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_LogisticRegression(X_train, X_test, y_train, y_test) 输出结果： 12345Coefficients: [[ 0.38705175 1.35839989 -2.12059692 -0.95444452] [ 0.23787852 -1.36235758 0.5982662 -1.26506299] [-1.50915807 -1.29436243 2.14148142 2.29611791]]Intercept: [ 0.23950369 1.14559506 -1.0941717 ]Score: 0.97 可以看到测试集中的预测结果性能得分为0.97（即预测准确率为97%）。 下面考察multi_class参数对分类结果的影响。默认采用的是one-vs-rest策略，但是逻辑回归模型原生就支持多类分类： 1234567def demo_LogisticRegression_multinomial(*data): X_train, X_test, y_train, y_test = data regr = linear_model.LogisticRegression(multi_class=&apos;multinomial&apos;, solver=&apos;lbfgs&apos;) regr.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % regr.coef_) print(&apos;Intercept: %s&apos; % regr.intercept_) print(&apos;Score: %.2f&apos; % regr.score(X_test, y_test)) 只有solver为牛顿法或者拟牛顿法才能配合multi_class='multinomial' 调用该函数： 12X_train, X_test, y_train, y_test = load_data()demo_LogisticRegression_multinomial(X_train, X_test, y_train, y_test) 结果如下： 12345Coefficients: [[-0.38350833 0.86199769 -2.26970401 -0.97473472] [ 0.34381965 -0.37903699 -0.03117965 -0.86837866] [ 0.03968868 -0.4829607 2.30088366 1.84311338]]Intercept: [ 8.75772577 2.49369071 -11.25141648]Score: 1.00 可以看到在这个问题中，多分类策略进一步提升了预测准确率。 最后，考察参数C对分类模型的预测性能的影响： 1234567891011121314151617def demo_LogisticRegression_C(*data): X_train, X_test, y_train, y_test = data Cs = np.logspace(-2, 4, num=100) scores = [] for C in Cs: regr = linear_model.LogisticRegression(C=C) regr.fit(X_train, y_train) scores.append(regr.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(Cs, scores) ax.set_xlabel(r&quot;C&quot;) ax.set_ylabel(r&quot;score&quot;) ax.set_xscale(&apos;log&apos;) ax.set_title(&quot;LogisticRegression&quot;) plt.show() 测试结果如下图： 可以看到随着C的增大（即正则化项的减小），预测准确率上升。当C增大到一定程度，预测准确率维持在较高的水准不变。 线性判别分析 在scikit-learn中，LinearDiscriminantAnalysis实现了线性判别分析模型： 123class sklearn.discriminant_analysis.LinearDiscriminantAnalysis( solver=&apos;svd&apos;, shrinkage=None, priors=None, n_components=None, store_covariance=False, tol=0.0001) 参数 solver: 一个字符串，指定求解最优化问题的算法 svd: 奇异值分解，对于有大规模特征的数据，推荐使用 lsqr: 最小平方差算法，可以结合shrinkage参数 eigen: 特征值分解算法，可以结合shrinkage参数 shrinkage: 通常在训练样本数量小于特征数量场合下使用，只有在solver=lsqr或者eigen下有意义 'auto': 根据Ledoit-Wolf引理来自动决定shrinkage参数大小 None: 不使用该参数 浮点数(0~1): 指定参数 priors: 一个数组，数组中元素依次指定了每个类别的先验概率。如果为None，则认为每个类的先验概率都是等可能的。 n_components: 一个整数，指定了数据降维后的维度(必须小于n_classes-1)。 store_covariance: boolean，如果为True，则需要额外计算每个类别的协方差矩阵\(\sum_i\)。 tol: 一个浮点数，指定了用于SVD算法中判断迭代收敛的阈值。 属性 coef_: 权重向量 intercept_: b值 covariance_: 一个数组，依次给出了每个类别的协方差矩阵 means_: 一个数组，依次给出了每个类别的均值向量 xbar_: 给出整体样本的均值向量 n_iter_: 实际迭代次数 方法 fit(X, y): 训练模型 predict(X): 用模型进行预测，返回预测值 predict_log_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率的对数值 predict_proba(X): 返回一个数组，数组的元素依次是X预测为各个类别的概率值 score(X, y[, sample_weight]): 返回在(X, y)上预测的准确率 依旧使用鸢尾花数据集： 1234567def demo_LinearDiscriminantAnalysis(*data): X_train, X_test, y_train, y_test = data lda = discriminant_analysis.LinearDiscriminantAnalysis() lda.fit(X_train, y_train) print(&apos;Coefficients: %s&apos; % lda.coef_) print(&apos;Intercept: %s&apos; % lda.intercept_) print(&apos;Score: %.2f&apos; % lda.score(X_test, y_test)) 结果如下： 12345Coefficients: [[ 6.66775427 9.63817442 -14.4828516 -20.9501241 ] [ -2.00416487 -3.51569814 4.27687513 2.44146469] [ -4.54086336 -5.96135848 9.93739814 18.02158943]]Intercept: [-15.46769144 0.60345075 -30.41543234]Score: 1.00 现在来检查一下原始数据集在经过线性判别分析LDA之后的数据集情况，绘制LDA降维之后的数据集： 123456789101112def plot_LDA(converted_X, y): fig = plt.figure() ax = Axes3D(fig) colors = &apos;rgb&apos; markers = &apos;o*s&apos; for target, color, marker in zip([0, 1, 2], colors, markers): pos = (y == target).ravel() X = converted_X[pos, :] ax.scatter(X[:, 0], X[:, 1], X[:, 2], color=color, marker=marker, label=&quot;Label %d&quot; % target) ax.legend(loc=&quot;best&quot;) fig.suptitle(&quot;Iris After LDA&quot;) plt.show() 调用： 1234567X_train, X_test, y_train, y_test = load_data()X = np.vstack((X_train, X_test))Y = np.vstack((y_train.reshape(y_train.size, 1), y_test.reshape(y_test.size, 1)))lda = discriminant_analysis.LinearDiscriminantAnalysis()lda.fit(X, Y)converted_X = np.dot(X, np.transpose(lda.coef_)) + lda.intercept_plot_LDA(converted_X, Y) 结果如下： 可以看到经过线性判别分析后，不同种类的鸢尾花之间的间隔较远，相同种类的鸢尾花之间已经相互聚集。 接下来考察不同的solver对预测性能的影响： 12345678910def demo_LinearDiscriminantAnalysis_solver(*data): X_train, X_test, y_train, y_test = data solvers = [&apos;svd&apos;, &apos;lsqr&apos;, &apos;eigen&apos;] for solver in solvers: if solver == &apos;svd&apos;: lda = discriminant_analysis.LinearDiscriminantAnalysis(solver=solver) else: lda = discriminant_analysis.LinearDiscriminantAnalysis(solver=solver, shrinkage=None) lda.fit(X_train, y_train) print(&apos;Score at solver = %s: %.2f&apos; % (solver, lda.score(X_test, y_test))) 结果如下，可以看出三者没有差别： 1234runfile(&apos;/Users/rian/Evil/LEARN/AI/blog/linear model/LinearDiscriminantAnalysis.py&apos;, wdir=&apos;/Users/rian/Evil/LEARN/AI/blog/linear model&apos;)Score at solver = svd: 1.00Score at solver = lsqr: 1.00Score at solver = eigen: 1.00 最后考察中solver=lsqr中引入抖动(相当于引入正则化项)： 1234567891011121314151617def demo_LinearDiscriminantAnalysis_shrinkage(*data): X_train, X_test, y_train, y_test = data shrinkages = np.linspace(0.0, 1.0, num=20) scores = [] for shrinkage in shrinkages: lda = discriminant_analysis.LinearDiscriminantAnalysis(solver=&apos;lsqr&apos;, shrinkage=shrinkage) lda.fit(X_train, y_train) scores.append(lda.score(X_test, y_test)) # 绘图 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(shrinkages, scores) ax.set_xlabel(r&quot;shrinkage&quot;) ax.set_ylabel(r&quot;score&quot;) ax.set_ylim(0, 1.05) ax.set_title(&quot;LinearDiscriminantAnalysis&quot;) plt.show() 结果： 可以发现随着shrinkage的增大，模型的准确率会随之下降]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>linear model</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My blog building experience]]></title>
    <url>%2F2019%2F07%2F19%2FMy-blog-building-experience%2F</url>
    <content type="text"><![CDATA[It's my first time to build a blog, maybe my experience can help the green hands. Operation System: macOS 2019.7.19 update, Github+hexo preparatory work install git download URL: https://git-scm.com/download After installing git successfully, we need to bind git and our Github account. open iTerm set the configuration information 12git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot; create ssh key file (the email should be the same as one above), copy the content of id_rsa.pub 1ssh-keygen -t rsa -C &quot;email&quot; open https://github.com/settings/keys, new ssh key. Paste the content of id_rsa.pub into the key, and then click "add ssh key". check Github public key, open iTerm 1ssh git@github.com install node.js download url: https://nodejs.org/en/download/ install hexo Hexo is the framework of our blog site. 1npm install -g hexo-cli build a blog build locally create a new folder named "blog" generate a hexo template 12cd bloghexo init run hexo server, we can see the blog have been built successfully through localhost:4000 link blog to Github create a new project named "github_name.github.io" open _config.yml, update deploy 1234deploy: type: git repository: https://github.com/github_name/github_name.github.io.git branch: master install plugin npm install hexo-deployer-git --save generate static files locally hexo g push to Github 1hexo d now we can visit https://github_name.github.io update blog content update article run hexo new "my first blog", then we can find a .md file in the source/_posts folder edit the file (Markdown) push to Github 123hexo cleanhexo ghexo d add menu edit /theme/XXX/_config.yml, find "menu:", add the menu you want add pages 1hexo new pages &quot;menu_name&quot; add pictures in the article create a folder, "/theme/XXX/source/upload_image", and save the pictures here 1![](/upload_image/a.jpg)]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
